category: 
- concurrency
title: java并发集合
---

java 提供了俩类用于并发的集合：
* 阻塞式集合:这类集合包括添加和移除数据的方法.当集合已满或为空时,被调用的添加或者移除的方法就不能立即被执行,那么调用这个方法的线程将被阻塞,一直到该方法可以被执行.
			  这种集合包括添加和删除数据的操作.如果操作不能立即进行,是因为集合已满或者为空,该程序将被阻塞,直到操作可以进行.
* 非阻塞式集合:这类集合也包括添加和移除数据的方法,如果方法不能被执行,则返回null或者抛出异常,但是调用这个方法的线程不会被阻塞.
				这种集合也包括添加和删除数据的操作.如果操作不能立即进行,这个操作将返回null值或抛出异常,但该线程将不会阻塞.
			  
如果我们要实现一个线程安全的队列有两种实现方式：一种是使用阻塞算法,另一种是使用非阻塞算法.使用阻塞算法的队列可以用一个锁(入队和出队用同一把锁)或两个锁(入队和出队用不同的锁)等方式来实现,而非阻塞的实现方式则可以使用循环CAS的方式来实现,

## 阻塞队列:

### 阻塞队列说明:
> 它实质上就是一种带有一点扭曲的 FIFO 数据结构.它提供了可阻塞的put和take方法.如果Queue已经满了,put方法会被阻塞直到有空间可用;如果Queue是空的,那么take方法会被阻塞,直到有元素可用.offer方法如果数据项不能被添加到队列中,会返回一个失败的状态.Queue的长度可用有限,也可以无限;无限的Queue永远不会充满,所以它的put方法永远不会被阻塞.阻塞队列支持生产者-消费者设计模式.BlockingQueue可以使用任意数量的生产者和消费者,从而简化了生产者-消费者设计的实现.

> Java6 新增了俩种新的容器类型 Deque和 BlockingDeque 分别对Queue 和BlockingQueue 进行了拓展Deque是一个双端队列,实现了在队列头和队列尾 > > > 高效的插入和移除.正如阻塞队列适用于生产者和消费者模式,双端队列适用于工作密取模式(工作密取模式非常适用于既是生产者又是消费者问题).

> ArrayDeque：Deque是基于有首尾指针的数组(环形缓冲区)实现的.和LinkedList不同,这个类没有实现List接口.因此,如果没有首尾元素的话就不能取出任何元素.这个类比LinkedList要好一些,因为它产生的垃圾数量较少(在扩展的时候旧的数组会被丢弃).Stack：一种后进先出的队列.不要在生产代码中使用,使用别的Deque来代替(ArrayDeque比较好).PriorityQueue：一个基于优先级的队列.使用自然顺序或者制定的比较器来排序.他的主要属性——poll/peek/remove/element会返回一个队列的最小值.不仅如此,PriorityQueue还实现了Iterable接口,队列迭代时不进行排序(或者其他顺序).在需要排序的集合中,使用这个队列会比TreeSet等其他队列要方便.

* `BlockingQueue`：简化了生产者-消费者实现过程,支持任意数量的生产者或者消费者.
* `ArrayBlockingQueue`：一个由数组结构(ArrayList)组成的有界阻塞队列.比同步List拥有更高的并发性.

基于数组实现的一个有界阻塞队,大小不能重新定义.所以当你试图向一个满的队列添加元素的时候,就会受到阻塞,直到另一个方法从队列中取出元素.

* `DelayQueue`：一个由优先级堆支持的、基于时间的调度队列.存储延迟元素的阻塞列表无界的保存Delayed元素的集合.元素只有在延时已经过期的时候才能被取出.队列的第一个元素延期最小(包含负值——延时已经过期).当你要实现一个延期任务的队列的时候使用(不要自己手动实现——使用ScheduledThreadPoolExecutor).

* `LinkedBlockingDeque`: 一个由链表结构组成的双向阻塞队列.可选择有界或者无界基于链表的实现.在队列为空或者满的情况下使用ReentrantLock-s.LinkedBlockingQueue与此一样

* `LinkedBlockingQueue`：一个由链表结构(LinkedList)组成的有界阻塞队列.比同步List拥有更高的并发性

* `LinkedTransferQueue`: 一个由链表结构组成的无界阻塞队列.基于链表的无界队列.除了通常的队列操作,它还有一系列的transfer方法,可以让生产者直接给等待的消费者传递信息,这样就不用将元素存储到队列中了.这是一个基于CAS操作的无锁集合.

* `PriorityBlockingQueue`：一个支持优先级排序的无界阻塞队列.PriorityQueue的无界的版本.

* `SynchronousQueue`：一个不存储元素的阻塞队列.它维护一组线程,这些线程在等待着吧元素加入或移除队列.一个有界队列,其中没有任何内存容量.这就意味着任何插入操作必须等到响应的取出操作才能执行,反之亦反.如果不需要Queue接口的话,通过Exchanger类也能完成响应的功能.


#### 非阻塞集合说明:

这一部分将介绍java.util.concurrent包中线程安全的集合.这些集合的主要属性是一个不可分割的必须执行的方法.因为并发的操作,例如add或update或者check再update,都有一次以上的调用,必须同步.因为第一步从集合中组合操作查询到的信息在开始第二步操作时可能变为无效数据.多数的并发集合是在Java 1.5引入的.ConcurrentSkipListMap / ConcurrentSkipListSet 和 LinkedBlockingDeque
是在Java 1.6新加入的.Java 1.7加入了最后的 ConcurrentLinkedDeque 和 LinkedTransferQueue


## 非阻塞集合:

* `ConcurrentHashMap`:  代替基于散列的Map,使用分段锁机制,任意数量的读取线程可以访问Map,读取线程和写入线程可以并发的访问Map, 一定数量的写入线程可以并发的修改Map.ConcurrentHashMap没有实现对Map加锁以提供独占访问 (Hashtable和synchronizedMap 都可以获得Map的锁以防止其他线程的访问).ConcurrentHashMap本身实现了很多原子复合操作,具体参考测试程序.

get操作全并发访问,put操作可配置并发操作的哈希表.并发的级别可以通过构造函数中concurrencyLevel参数设置(默认级别16).该参数会在Map内部划分一些分区.在put操作的时候只有只有更新的分区是锁住的.
这种Map不是代替HashMap的线程安全版本——任何 get-then-put的操作都需要在外部进行同步.

* `ConcurrentLinkedDeque`: 非阻塞列表. 基于链表实现的无界队列,添加元素不会堵塞.但是这就要求这个集合的消费者工作速度至少要和生产这一样快,不然内存就会耗尽.严重依赖于CAS(compare-and-set)操作.

* `ConcurrentLinkedQueue`: 一个传统的先进先出队列

* `ConcurrentSkipListMap`: 作为同步的SortedMap.基于跳跃列表(Skip List)的ConcurrentNavigableMap实现.本质上这种集合可以当做一种TreeMap的线程安全版本来使用

* `ConcurrentSkipListSet`: 作为同步的SortedSet.使用 ConcurrentSkipListMap来存储的线程安全的Set.

* `CopyOnWriteArrayList`: list的实现每一次更新都会产生一个新的隐含数组副本,所以这个操作成本很高.通常用在遍历操作比更新操作多的集合,比如listeners/observers集合.最适合于读操作通常大大超过写操作的情况.代替遍历操作为主要操作的同步的List.如果写大于读的并发用什么?

* `CopyOnWriteArraySet`: 最适合于读操作通常大大超过写操作的情况.使用CopyOnWriteArrayList来存储的线程安全的Set


# LinkedBlockingQueue
是一个用链表实现的有界阻塞队列.此队列的默认和最大长度为Integer.MAX_VALUE.此队列按照先进先出的原则对元素进行排序.

一种通过链表实现的阻塞队列，支持先进先出.队列的头部是队列中保持时间最长的元素，队列的尾部是保持时间最短的元素.新元素插入队列的尾部.可选的容量设置可以有效防止队列过于扩张造成系统资源的过多消耗，如果不指定队列容量，队列默认使用Integer.MAX_VALUE.LinkedBlockingQueue的特定是，支持无限（理论上）容量.

LinkedBlockingQueue是一个基于已链接节点的、范围任意的blocking queue的实现.此队列按FIFO（先进先出）排序元素.队列的头部 是在队列中时间最长的元素.队列的尾部 是在队列中时间最短的元素.

新元素插入到队列的尾部,并且队列检索操作会获得位于队列头部的元素.

链接队列的吞吐量通常要高于基于数组的队列,

但是在大多数并发应用程序中,其可预知的性能要低.可选的容量范围构造方法参数作为防止队列过度扩展的一种方法.如果未指定容量,则它等于Integer.MAX_VALUE.除非插入节点会使队列超出容量,否则每次插入后会动态地创建链接节点.

1. 如果未指定容量,默认容量为Integer.MAX_VALUE ,容量范围可以在构造方法参数中指定作为防止队列过度扩展.
2. 此对象是 线程阻塞-安全的
3. 不接受 null 元素
4. 它实现了BlockingQueue接口.
5. 实现了 Collection 和 Iterator 接口的所有可选 方法.


# CopyOnWriteArrayList

1. CopyOnWriteArrayList（写数组的拷贝）是ArrayList的一个线程安全的变体,CopyOnWriteArrayList和CopyOnWriteSet都是线程安全的集合,其中所有可变操作（add、set等等）都是通过对底层数组进行一次新的复制来实现的。

2. 它绝对不会抛出ConcurrentModificationException的异常。因为该列表（CopyOnWriteArrayList）在遍历时将不会被做任何的修改。

3. CopyOnWriteArrayList适合用在“读多,写少”的“并发”应用中,换句话说,它适合使用在读操作远远大于写操作的场景里,比如缓存。它不存在“扩容”的概念,每次写操作（add or remove）都要copy一个副本,在副本的基础上修改后改变array引用,所以称为“CopyOnWrite”,因此在写操作是加锁,并且对整个list的copy操作时相当耗时的,过多的写操作不推荐使用该存储结构。

4. CopyOnWriteArrayList的功能是是创建一个列表,有三种构造方法：
   >（1）CopyOnWriteArrayList ()创建一个空列表。
   >（2）CopyOnWriteArrayList (Collection<? extendsE> c) 创建一个按 collection的迭代器返回元素的顺序包含指定 collection元素的列表。
   >（3）CopyOnWriteArrayList（E[] toCopyIn） 创建一个保存给定数组的副本的列表。


# CopyOnWriteArraySet
它是线程安全的无序的集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过“散列表(HashMap)”实现的，而CopyOnWriteArraySet则是通过“动态数组(CopyOnWriteArrayList)”实现的，并不是散列表。和CopyOnWriteArrayList类似，CopyOnWriteArraySet具有以下特性： 
1. 它最适合于具有以下特征的应用程序：Set大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。 
2. 它是线程安全的。 
3. 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。 
4. 迭代器支持hasNext(),next()等不可变操作，但不支持可变 remove()等 操作。 
5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。

# ConcurrentSkipListSet
ConcurrentSkipListSet（提供的功能类似于TreeSet，能够并发的访问有序的set。因为ConcurrentSkipListSet是基于“跳跃列表（skip list）”实现的，只要多个线程没有同时修改集合的同一个部分，那么在正常读、写集合的操作中不会出现竞争现象。

ConcurrentSkipListSet是线程安全的有序的集合，适用于高并发的场景。ConcurrentSkipListSet和TreeSet，它们虽然都是有序的集合。但是:
1. 它们的线程安全机制不同，TreeSet是非线程安全的，而ConcurrentSkipListSet是线程安全的。
2. ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，而TreeSet是通过TreeMap实现的。

ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，它的接口基本上都是通过调用ConcurrentSkipListMap接口来实现的

# ConcurrentLinkedQueue
ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael & Scott算法上进行了一些修改


# LinkedBlockingDeque

LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列.

## 双向队列
所谓双向队列指的你可以从队列的两端插入和移出元素.双端队列因为多了一个操作队列的入口,在多线程同时入队时,也就减少了一半的竞争.

## 相比其他的阻塞队列
LinkedBlockingDeque多了
```
addFirst,
addLast,
offerFirst,
offerLast,
peekFirst,
peekLast
```
等方法.

* 以First单词结尾的方法,表示插入,获取（peek）或移除双端队列的第一个元素.
* 以Last单词结尾的方法,表示插入,获取或移除双端队列的最后一个元素.
* 插入方法add等同于addLast,
* 移除方法remove等效于removeFirst.
* take方法却等同于takeFirst (不知道是不是Jdk的bug,使用时还是用带有First和Last后缀的方法更清楚).

在初始化LinkedBlockingDeque时可以初始化队列的容量 ,用来防止其再扩容时过渡膨胀.另外双向阻塞队列可以运用在“工作窃取”模式中.

> 阻塞式并发列表与非阻塞式并发列表主要区别在于：
> 阻塞式并发列表在插入或者删除元素时,如果列表已满或者列表为空,操作不会立即被执行,而是将调用这个操作的线程阻塞队列直到操作可以执行成功.

* takeFirst();  // 返回并移除列表中的第一个元素,列表为空线程将阻塞
* takeLast();   // 返回并移除列表中的最后一个元素,列表为空线程将阻塞
* pollFirst();  // 返回并移除列表中的第一个元素,列表为空返回null
* pollLast();  // 返回并移除列表中的最后一个元素,列表为空返回null

* getFirst();   // 返回列表中的第一个元素但不移除,列表为空抛出NoSuchElementException
* getLast();    // 返回列表中的最后一个元素但不移除,列表为空抛出NoSuchElementException
* peek();       // 返回列表中的第一个元素但不移除,列表为空返回null
* peekFirst();  // 返回列表中的第一个元素但不移除,列表为空返回null
* peekLast();   // 返回列表中的最后一个元素但不移除,列表为空返回null

# ConcurrentHashMap

concurrentHashMap与ConcurrentSkipListMap性能测试 在4线程1.6万数据的条件下，ConcurrentHashMap存取速度是ConcurrentSkipListMap 的4倍左右。

但ConcurrentSkipListMap有几个ConcurrentHashMap 不能比拟的优点：
1、ConcurrentSkipListMap 的key是有序的。
2、ConcurrentSkipListMap 支持更高的并发。ConcurrentSkipListMap的存取时间是log（N），和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出他的优势。

> 使用建议 在非多线程的情况下，应当尽量使用TreeMap。此外对于并发性相对较低的并行程序可以使用Collections.synchronizedSortedMap将TreeMap进行包装，也可以提供较好的效率。对于高并发程序，应当使用ConcurrentSkipListMap，能够提供更高的并发度。


所以在多线程程序中，如果需要对Map的键值进行排序时，请尽量使用ConcurrentSkipListMap，可能得到更好的并发度。注意，调用ConcurrentSkipListMap的size时，由于多个线程可以同时对映射表进行操作，所以映射表需要遍历整个链表才能返回元素个数，这个操作是个O(log(n))的操作。

ConcurrentSkipListMap提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上能够在O(log(n))时间内完成查找、插入、删除操作。注意，调用ConcurrentSkipListMap的size时，由于多个线程可以同时对映射表进行操作，所以映射表需要遍历整个链表才能返回元素个数，这个操作是个O(log(n))的操作。


ConcurrentNavigableMap 接口以及其实现类 ConcurrentSkipListMap该接口与实现类有相同行为的非阻塞式列表.当插入元素时ConcurrentSkipListMap 使用键值排序插入元素


# ConcurrentLinkedDeque 为非阻塞式并发列表.

并发列表允许不同的线程在同一时间添加或移除列表中的元素,而不会造成数据不一致

`ConcurrentLinkedQueue`是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了`wait－free`算法来实现，该算法在Michael & Scott算法上进行了一些修改,

## 方法简介
* `list.pollFirst()`    // 返回并移除列表中的第一个元素,列表为空返回null
* `list.pollLast()`     // 返回并移除列表中的最后一个元素,列表为空返回null
* `list.remove()`       // 返回并移除列表中的第一个元素,列表为空抛出NoSuchElementException
* `list.removeFirst()`  // 返回并移除列表中的第一个元素,列表为空抛出NoSuchElementException
* `list.removeLast()`   // 返回并移除列表中的最后一个元素,列表为空抛出NoSuchElementException

* `list.getFirst()`     // 返回列表中的第一个元素但不移除,列表为空抛出NoSuchElementException
* `list.getLast()`      // 返回列表中的最后一个元素但不移除,列表为空抛出NoSuchElementException
* `list.peek()`         // 返回列表中的第一个元素但不移除,列表为空返回null
* `list.peekFirst()`        // 返回列表中的第一个元素但不移除,列表为空返回null
* `list.peekLast()`     // 返回列表中的最后一个元素但不移除,列表为空返回null


# DelayQueue
一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue运用在以下应用场景：

缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。 定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。队列中的Delayed必须实现compareTo来指定元素的顺序。比如让延时时间最长的放在队列的末尾

一个无界阻塞队列，只有在延时期满时才能从中提取元素。如果没有元素到达延时期，则没有头元素


DelayQueue里存放的元素必须实现Delayed接口(该接口使对象称为延迟对象).
实现Delayed接口的对象,到了指定日期将强制执行compareTo(Delayed o),getDelay(TimeUnit unit)这俩个方法


# PriorityBlockingQueue

`PriorityBlockingQueue`是一个支持优先级的无界队列.默认情况下元素采取自然顺序排列,也可以通过比较器`comparator`来指定元素的排序规则.元素按照升序排列,这与构造队列时,提供的参数有关.

使用提取方法时,队列将返回头部,具有最高优先级(或最低优先级,这与排序规则有关)的元素.如果多个元素具有相同的优先级,则同等优先级间的元素获取次序无特殊说明.

优先级队列使用的是一种可扩展的数组结构,一般可以认为这个队列是无界的.当需要新添加一个元素时,如果此时数组已经被填满,优先队列将会自动扩充当前数组.(一般认为是,先分配一个原数组一定倍数空间的数组,之后将原数组中的元素拷贝到新分配的数组中,释放原数组的空间).

如果使用优先级队列的`iterator`变量队列时,不保证遍历次序按照优先级大小进行.因为优先级队列使用的是堆结构.如果需要按照次序遍历需要使用`Arrays.sort(pq.toArray())`.

在`PriorityBlockingQueue`的实现过程中聚合了`PriorityQueue`的一个实例,并且优先队列的操作完全依赖与`PriorityQueue`的实现.在`PriorityQueue`中使用了一个一维数组来存储相关的元素信息.一维数组使用最小堆算法进行元素添加.`PriorityBlockingQueue` 按优先级排序的阻塞时线程安全列表

与`LinkedBlockingDeque` 一样,它也是一个阻塞时并发列表

# Skip list

Skip list(跳表)说明

> 是一种可以代替平衡树的数据结构,默认是按照Key值升序的.Skip list让已排序的数据分布在多层链表中,以0-1随机数决定一个数据的向上攀升与否,通过“空间来换取时间”的一个算法,在每个节点中增加了向前的指针,在插入、删除、查找时可以忽略一些不可能涉及到的结点,从而提高了效率.

从概率上保持数据结构的平衡比显示的保持数据结构平衡要简单的多.对于大多数应用,用Skip list要比用树算法相对简单.由于Skip list比较简单,实现起来会比较容易,虽然和平衡树有着相同的时间复杂度(O(logn)),但是skip list的常数项会相对小很多.Skip list在空间上也比较节省.一个节点平均只需要1.333个指针(甚至更少).

Skip list的性质
1. 由很多层结构组成,level是通过一定的概率随机产生的.
2. 每一层都是一个有序的链表,默认是升序,也可以根据创建映射时所提供的Comparator进行排序,具体取决于使用的构造方法.
3. 最底层(Level 1)的链表包含所有元素.
4. 如果一个元素出现在Level i 的链表中,则它在Level i 之下的链表也都会出现.
5. 每个节点包含两个指针,一个指向同一链表中的下一个元素,一个指向下面一层的元素.

# LinkedTransferQueue

LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列LinkedTransferQueue多了tryTransfer和transfer方法。

transfer方法。如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。transfer方法的关键代码如下：
```java
Node pred = tryAppend(s, haveData);
return awaitMatch(s, pred, e, (how == TIMED), nanos);
```
第一行代码是试图把存放当前元素的s节点作为tail节点。第二行代码是让CPU自旋等待消费者消费元素。因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其他线程。

tryTransfer方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。

对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。


# ArrayBlockingQueue

一个线程安全的、基于数组、有界的、阻塞的、FIFO 队列

ArrayBlockingQueue是一个用数组实现的有界阻塞队列.此队列按照先进先出（FIFO）的原则对元素进行排序.默认情况下不保证访问者公平的访问队列.通常情况下为了保证公平性会降低吞吐量.

(所谓公平访问队列是指阻塞的所有生产者线程或消费者线程,当队列可用时,可以按照阻塞的先后顺序访问队列,即先阻塞的生产者线程)

队列头部元素是队列中存在时间最长的元素,队列尾部是存在时间最短的元素,新元素将会被插入到队列尾部.队列从头部开始获取元素.

ArrayBlockingQueue是“有界缓存区”模型的一种实现,一旦创建了这样的缓存区,就不能再改变缓冲区的大小.ArrayBlockingQueue的一个特点是,必须在创建的时候指定队列的大小.当缓冲区已满,则需要阻塞新增的插入操作,同理,当缓冲区已空需要阻塞新增的提取操作.

ArrayBlockingQueue是使用的是循环队列方法实现的,对ArrayBlockingQueue的相关操作的时间复杂度,可以参考循环队列进行分析

此类基于 java.util.concurrent.locks.ReentrantLock 来实现线程安全，所以提供了 ReentrantLock 所能支持的公平性选择。

```
final ArrayBlockingQueue<String> queue = new ArrayBlockingQueue<>(10);	// 默认情况下不保证访问者公平的访问队列
final ArrayBlockingQueue<String> queue = new ArrayBlockingQueue<>(10, true);	// 保证访问者公平的访问队列
```


# synchronize2.0

同步容器类

将他们的状态都封装起来,并对每个共有方法都进行同步,使得每次只有一个线程能访问容器的状态

同步容器类都是线程安全的,但是某些情况下客户端可能需要加锁来保护复合操作的安全性例如有些线程在进行复合操作,但是有一些线程在并发的修改同步容器类

常见的复合操作有(迭代,跳转,条件运算(如果没有则添加))

Collections 提供了对集合和map的同步包装方法.但是我们发现其对List的内部实现SynchronizedList 的每一个public方法内部都加了一把内置锁也就是说都进行了synchronized操作

但是加锁对象mutex 是被定义在SynchronizedCollection里的而SynchronizedList<E> extends SynchronizedCollection<E>

那么问题就来了 在使用同步包装器的时候 容器本身是线程安全的(因为他们都持有SynchronizedCollection共同的锁),但是在外部 如果进行复合操作的话, 例如线程A从容器里get元素V,但是线程B从容器里remove掉元素V且B先执行于A,好了,在容器内部完成了并发安全, 但是在业务逻辑上很显然这是不安全的

所以在使用同步包装器的时候必须在业务逻辑上完成并发处理的操作
 
## 2.0
同步的集合包装器 synchronizedMap 和 synchronizedList ,有时也被称作 有条件地线程安全――所有单个的操作都是线程安全的,但是多个操作组成的操作序列却可能导致数据争用,因为在操作序列中控制流取决于前面操作的结果.例如对于这样的功能put-if-absent语句块――如果一个条目不在Map 中,那么添加这个条目.该功能通过containsKey() 方法和 put() 方法组合起来.要保证原子性操作,就需要对该语句块加上同步锁.而且同步容器是对每个操作都进行同步,当大数据量或者多个线程下,会造成严重的并发性能下降.通过将基本的功能从线程安全性中分离开来,Collections.synchronizedMap 允许需要同步的用户可以拥有同步,而不需要同步的用户则不必为同步付出代价.

## 第一组方法主要返回集合的各种数据：
* 检查要添加的元素的类型并返回结果.任何尝试添加非法类型的变量都会抛出一个ClassCastException异常.这个功能可以防止在运行的时候出错.
```
Collections.checkedCollection
Collections.checkedList
Collections.checkedMap
Collections.checkedSet
Collections.checkedSortedMap
Collections.checkedSortedSet：
```
* 返回一个固定的空集合,不能添加任何元素.
```
Collections.emptyList
Collections.emptyMap
Collections.emptySet ：
```
* 返回一个只有一个入口的 set/list/map 集合.
```
Collections.singleton
Collections.singletonList
Collections.singletonMap：
```
* 获得集合的线程安全版本(多线程操作时开销低但不高效,而且不支持类似put或update这样的复合操作)
```
Collections.synchronizedCollection
Collections.synchronizedList
Collections.synchronizedMap
Collections.synchronizedSet
Collections.synchronizedSortedMap
Collections.synchronizedSortedSet：
```
* 返回一个不可变的集合.当一个不可变对象中包含集合的时候,可以使用此方法.
```
Collections.unmodifiableCollection
Collections.unmodifiableList
Collections.unmodifiableMap
Collections.unmodifiableSet
Collections.unmodifiableSortedMap
Collections.unmodifiableSortedSet：
```

## 第二组方法中,其中有一些方法因为某些原因没有加入到集合中：
* Collections.addAll：添加一些元素或者一个数组的内容到集合中.
* Collections.binarySearch：和数组的Arrays.binarySearch功能相同.
* Collections.disjoint：检查两个集合是不是没有相同的元素.
* Collections.fill：用一个指定的值代替集合中的所有元素.
* Collections.frequency：集合中有多少元素是和给定元素相同的.
* Collections.indexOfSubList / lastIndexOfSubList：和String.indexOf(String) / lastIndexOf(String)方法类似——找出给定的List中第一个出现或者最后一个出现的子表.
* Collections.max / min：找出基于自然顺序或者比较器排序的集合中,最大的或者最小的元素.
* Collections.replaceAll：将集合中的某一元素替换成另一个元素.
* Collections.reverse：颠倒排列元素在集合中的顺序.如果你要在排序之后使用这个方法的话,在列表排序时,最好使用Collections.reverseOrder比较器.
* Collections.rotate：根据给定的距离旋转元素.
* Collections.shuffle：随机排放List集合中的节点,可以给定你自己的生成器——例如 java.util.Random / java.util.ThreadLocalRandom or java.security.SecureRandom.
* Collections.sort：将集合按照自然顺序或者给定的顺序排序.
* Collections.swap：交换集合中两个元素的位置(多数开发者都是自己实现这个操作的).