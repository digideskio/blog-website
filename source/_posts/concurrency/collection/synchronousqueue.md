# SynchronousQueue

SynchronousQueue是一个不存储元素的阻塞队列.每一个put操作必须等待一个take操作,否则不能继续添加元素.反之亦然.同步队列没有任何内部容量,甚至连一个队列的容量都没有.

SynchronousQueue可以看成是一个传球手,负责把生产者线程处理的数据直接传递给消费者线程.队列本身并不存储任何元素,非常适合于传递性场景,比如在一个线程中使用的数据,

传递给另外一个线程使用,SynchronousQueue的吞吐量高于LinkedBlockingQueue 和 ArrayBlockingQueue.


不能在同步队列上进行 peek,因为仅在试图要取得元素时,该元素才存在;除非另一个线程试图移除某个元素,否则也不能(使用任何方法)添加元素;
也不能迭代队列,因为其中没有元素可用于迭代.队列的头是尝试添加到队列中的首个已排队线程元素; 如果没有已排队线程,则不添加元素并且头为 null.

对于其他 Collection 方法(例如 contains),SynchronousQueue 作为一个空集合.此队列不允许 null 元素.

同步队列非常适合于传递性设计,在这种设计中,在一个线程中运行的对象要将某些信息,事件或任务传递给在另一个线程中运行的对象,它就必须与该对象同步.

对于正在等待的生产者和使用者线程而言,此类支持可选的公平排序策略.

默认情况下不保证这种排序. 但是,使用公平设置为 true 所构造的队列可保证线程以 FIFO 的顺序进行访问.公平通常会降低吞吐量,但是可以减小可变性并避免得不到服务.


ConcurrentSkipListSet（提供的功能类似于TreeSet，能够并发的访问有序的set。因为ConcurrentSkipListSet是基于“跳跃列表（skip list）”实现的，只要多个线程没有同时修改集合的同一个部分，那么在正常读、写集合的操作中不会出现竞争现象。

ConcurrentSkipListSet是线程安全的有序的集合，适用于高并发的场景。
ConcurrentSkipListSet和TreeSet，它们虽然都是有序的集合。但是，
第一，它们的线程安全机制不同，TreeSet是非线程安全的，而ConcurrentSkipListSet是线程安全的。
第二，ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，而TreeSet是通过TreeMap实现的。

ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，它的接口基本上都是通过调用ConcurrentSkipListMap接口来实现的

