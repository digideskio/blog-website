1. wait()方法是Object类里的方法;当一个线程执行到wait()方法时,它就进入到一个和该对象相关的等待池中,
同时失去(释放)了对象的机锁(暂时失去机锁,wait(long timeout)超时时间到后还需要返还对象锁);其他线程可以访问;
2. wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。
3. wiat()必须放在synchronized(this) {}中,否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。

1. sleep()使当前线程进入停滞状态(阻塞当前线程),让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源,
以留一定时间给其他线程执行的机会;
2. sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁,所以当在一个Synchronized块中调用Sleep()方法是,
线程虽然休眠了,但是对象的机锁并木有被释放,其他线程无法访问这个对象(即使睡着也持有对象锁)。
3. 在sleep()休眠时间期满后,该线程不一定会立即执行,这是因为其它线程可能正在运行而且没有被调度为放弃执行,
除非此线程具有更高的优先级。

```java
public class TestWait {

	public static void main(String[] args) {

		WaitThread wt = new WaitThread();

		wt.start();

		try {
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		long now = System.currentTimeMillis();
		while((System.currentTimeMillis() - now) % 1000 == 0) {
			wt.print();
		}
	}
}

class WaitThread extends Thread {

	@Override
	public void run() {
		long old = System.currentTimeMillis();
		System.out.println("SleepThread run and start sleep 10s -- ");
		try {
			synchronized (this) {
				wait(10000);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("SleepThread wake up ---" + (System.currentTimeMillis() - old));
	}


	public void print() {
		synchronized (this) {
			System.out.println(System.currentTimeMillis());
		}
	}
}



```

* 用notify() 唤醒 wait()堵塞的线程
```java
public class TestNotify {

	public static void main(String[] args) {
		NotifyThread nt = new NotifyThread();
		nt.start();

		try {
			TimeUnit.SECONDS.sleep(3);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		System.out.println("notify start");
		nt.callNotify();
		System.out.println("notify over");
	}
}

class NotifyThread extends Thread {

	@Override
	public void run() {
		long old = System.currentTimeMillis();
		System.out.println("NotifyThread run");
		try {
			synchronized (this) {
				wait(10000);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("SleepThread wake up ---" + (System.currentTimeMillis() - old));
	}

	public void callNotify() {
		synchronized (this) {
			notify();
		}
	}
}
```

```java
public class TestSleepWithLock {

	public static void main(String[] args) {
		Object lock = new Object();

		SleepThreadWithLock sleep = new SleepThreadWithLock(lock);
		SimpleThreadWithLock simple = new SimpleThreadWithLock(lock);

		sleep.start();
		simple.start();
	}

}

class SleepThreadWithLock extends Thread {

	private Object lock;

	public SleepThreadWithLock(Object lock) {
		this.lock = lock;
	}

	@Override
	public void run() {
		long old = System.currentTimeMillis();
		System.out.println("SleepThread run and start sleep 10s -- ");
		try {
			synchronized (lock) {
				sleep(10000);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("SleepThread wake up ---"
				+ (System.currentTimeMillis() - old));
	}

}

class SimpleThreadWithLock extends Thread {

	private Object lock;

	public SimpleThreadWithLock(Object lock) {
		this.lock = lock;
	}

	@Override
	public void run() {
		try {
			/**
			 * SimpleThread sleep2s确保SleepThread 获得Object对象锁之后
			 */
			sleep(2000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		synchronized (lock) {
			System.out.println("SimpleThread");
		}
	}

}

```


```java
public class TestSleepNonLock {

	public static void main(String[] args) {
		SleepThread sleep = new SleepThread();
		SimpleThread simple1  = new SimpleThread(1);
		SimpleThread simple2  = new SimpleThread(2);
		SimpleThread simple3  = new SimpleThread(3);
		System.out.println("A : " + getState(sleep, simple1, simple2, simple3));
		sleep.start();
		System.out.println("B : " + getState(sleep, simple1, simple2, simple3));
		simple1.start();
		System.out.println("C : " + getState(sleep, simple1, simple2, simple3));
		simple2.start();
		System.out.println("D : " + getState(sleep, simple1, simple2, simple3));
		simple3.start();
		System.out.println("E : " + getState(sleep, simple1, simple2, simple3));
	}

	private static String getState(Thread... t) {
		StringBuffer buffer = new StringBuffer();
		for (Thread thread : t) {
			buffer.append(thread.getState().name() + "...");
		}
		return buffer.toString();
	}
}

class SleepThread extends Thread {

	@Override
	public void run() {
		long old = System.currentTimeMillis();
		System.out.println("SleepThread run and start sleep 10s -- ");
		try {
				sleep(10000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("SleepThread wake up ---" + (System.currentTimeMillis() - old));
	}

}

class SimpleThread extends Thread {

	private int id;
	SimpleThread(int id) {
		this.id = id;
	}
	@Override
	public void run() {
		System.out.println("SimpleThread" + id);
	}
}
```
