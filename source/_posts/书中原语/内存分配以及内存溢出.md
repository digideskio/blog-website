category: 书中原语
tag: JVM原理
date: 2014-10-08
title: 内存分配以及内存溢出
---

### Eden区
对象优先在Eden分配

大多数情况下,对象在新生代`Eden`区中分配.当`Eden`区没有足够的空间进行分配时,虚拟机将发起一次`Minor GC`.

虚拟机提供了`-XX:+PrintGCDetails`这个收集器日志参数,告诉虚拟机在发生垃圾收集行为时打印内存回收日志,并且在进程退出的时候输出当前内存各区域的分配情况.在实际应用中,内存回收日志一般是打印到文件后通过日志工具进行分析.

1. 新生代GC(`Minor GC`)：新生代GC, Java对象大多都朝生夕灭,所以`Minor GC`非常频繁,回收速度也比较快.
2. 老年代GC(`Major GC/Full GC`)：老年代GC,出现了Major GC,经常会伴随至少一次的Minor GC. MajorGC的速度一般会比Minor GC慢10倍以上.

> 注意ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程,而不必先进行Minor GC

示例代码
```java
private static final int _1MB = 1024 * 1024;

/**
  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
  */
public static void testAllocation() {
	    byte[] allocation1, allocation2, allocation3, allocation4;
	    allocation1 = new byte[2 * _1MB];
	    allocation2 = new byte[2 * _1MB];
	    allocation3 = new byte[2 * _1MB];
	    allocation4 = new byte[4 * _1MB];  // 出现一次Minor GC
}
```
分析如下：

1. `testAllocation()`方法中,尝试分配3个2MB大小和1个4MB大小的对象, 在运行时通过`-Xms20M、 -Xmx20M`和`-Xmn10M`这3个参数限制Java堆大小为20MB,且不可扩展,其中10MB分配给新生代,剩下的10MB分配给老年代.
2. `-XX:SurvivorRatio=8`决定了新生代中Eden区与一个`Survivor`区的空间比例是8比1,从输出的结果也能清晰地看到`“eden space 8192K、from space 1024K、to space 1024K”`的信息,新生代总可用空间为`9216KB`(`Eden`区+1个`Survivor`区的总容量).
3. 执行`testAllocation()`中分配`allocation4`对象的语句时会发生一次Minor GC,这次GC的结果是新生代6651KB变为148KB,而总内存占用量则几乎没有减少(因为allocation1、2、3三个对象都是存活的,虚拟机几乎没有找到可回收的对象).
4. 这次GC发生的原因是给allocation4分配内存的时候,发现Eden已经被占用了6MB,剩余空间已不足以分配allocation4所需的4MB内存,因此发生Minor GC.GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间(Survivor空间只有1MB大小),所以只好通过分配担保机制提前转移到老年代去.
5. 这次GC结束后,4MB的allocation4对象被顺利分配在Eden中.因此程序执行完的结果是Eden占用4MB(被allocation4占用),Survivor空闲,老年代被占用6MB(被allocation1、2、3占用).通过GC日志可以证实这一点.

### 老年代
大对象直接进入老年代

所谓大对象就是指,需要大量连续内存空间的Java对象,最典型的大对象就是那种很长的字符串及数组(例子中的byte[]数组就是典型的大对象).大对象对虚拟机的内存分配来说就是一个坏消息(替Java虚拟机抱怨一句,比遇到一个大对象更加坏的消息 就是遇到一群“朝生夕灭”的“短命大对象”,写程序的时候应当避免),经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们.

虚拟机提供了一个`-XX:PretenureSizeThreshold`参数,令大于这个设置值的对象直接在老年代中分配.这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝(复习一下：新生代采用复制算法收集内存).

执行代码清单3-4中的`testPretenureSizeThreshold()`方法后,我们看到Eden空间几乎没有被使用,而老年代10MB的空间被使用了40%,也就是4MB的allocation对象直接就分配在老年代中,这是因为`PretenureSizeThreshold`被设置为3MB(就是3145728B,这个参数不能与`-Xmx`之类的参数一样直接写3MB),因此超过3MB的对象都会直接在老年代中进行分配.

> 注意　`PretenureSizeThreshold`参数只对Serial和ParNew两款收集器有效,`Parallel Scavenge`收集器不认识这个参数,`Parallel Scavenge`收集器一般并不需要设置.如果遇到必须使用此参数的场合,可以考虑ParNew加CMS的收集器组合.

示例代码
```java
private static final int _1MB = 1024 * 1024;

/**
  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
  * -XX:PretenureSizeThreshold=3145728
  */
public static void testPretenureSizeThreshold() {
	　byte[] allocation;
	　allocation = new byte[4 * _1MB];  //直接分配在老年代中
}
```

长期存活的对象将进入老年代

虚拟机既然采用了分代收集的思想来管理内存,那内存回收时就必须能识别哪些对象应当放在新生代,哪些对象应放在老年代中.为了做到这点,虚拟机给每个对象定义了一个对象年龄(Age)计数器.如果对象在Eden出生并经过第一次Minor GC后仍然存活,	并且能被Survivor容纳的话,将被移动到Survivor空间中,并将对象年龄设为1.对象在Survivor区中每熬过一次Minor GC,年龄就增加1岁,当它的年龄增加到一定程度(默认为15岁)时,就会被晋升到老年代中.对象晋升老年代的年龄阈值,可以通过参数`-XX:MaxTenuringThreshold`来设置.

读者可以试试分别以`-XX:MaxTenuringThreshold=1`和`-XX:MaxTenuringThreshold=15`两种设置来执行代码清单3-5中的`testTenuringThreshold()`方法,此方法中allocation1对象需要256KB的内存空间,Survivor空间可以容纳.当MaxTenuringThreshold=1时,allocation1对象在第二次GC发生时进入老年代,新生代已使用的内存GC后会非常干净地变成0KB.而MaxTenuringThreshold=15时,第二次GC发生后,allocation1对象则还留在新生代Survivor空间,这时候新生代仍然有404KB的空间被占用.

实例代码
```java
private static final int _1MB = 1024 * 1024;

/**
  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M
  * -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1
  * -XX:+PrintTenuringDistribution
  */
@SuppressWarnings("unused")
public static void testTenuringThreshold() {
	 byte[] allocation1, allocation2, allocation3;
	 allocation1 = new byte[_1MB / 4];
	  // 什么时候进入老年代取决于XX:MaxTenuringThreshold设置
	 allocation2 = new byte[4 * _1MB];
	 allocation3 = new byte[4 * _1MB];
	 allocation3 = null;
	 allocation3 = new byte[4 * _1MB];
}
```

#### 动态年龄判断

为了能更好地适应不同程序的内存状况,虚拟机并不总是要求对象的年龄必须达到`MaxTenuringThreshold`才能晋升老年代,如果在`Survivor`空间中相同年龄所有对象大小的总和大于`Survivor`空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代,无须等到`MaxTenuringThreshold`中要求的年龄.

执行代码清单3-6中的testTenuringThreshold2()方法,并设置参数`-XX: MaxTenuringThreshold=15`,会发现运行结果中`Survivor`的空间占用仍然为0%,而老年代比预期增加了`6%`,也就是说`allocation1、allocation2`对象都直接进入了老年代,而没有等到15岁的临界年龄.因为这两个对象加起来已经达到了512KB,并且它们是同年的,满足同年对象达到Survivor空间的一半规则.我们只要注释掉其中一个对象的new操作,就会发现另外一个不会晋升到老年代中去了.

示例代码
```java
	private static final int _1MB = 1024 #### 1024;

	/**
	  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M
	  * -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15
	  * -XX:+PrintTenuringDistribution
	  */
	@SuppressWarnings("unused")
	public static void testTenuringThreshold2() {
		 byte[] allocation1, allocation2, allocation3, allocation4;
		 allocation1 = new byte[_1MB / 4];
		  // allocation1+allocation2大于survivor空间的一半
		 allocation2 = new byte[_1MB / 4];
		 allocation3 = new byte[4 #### _1MB];
		 allocation4 = new byte[4 #### _1MB];
		 allocation4 = null;
		 allocation4 = new byte[4 #### _1MB];
	}
```

#### 空间分配担保

在发生Minor GC时,虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小,如果大于,则改为直接进行一次Full GC.如果小于,则查看HandlePromotionFailure设置是否允许担保失败;如果允许,那只会进行Minor GC;如果不允许,则也要改为进行一次Full GC.

前面提到过,新生代使用复制收集算法,但为了内存利用率,只使用其中一个Survivor空间来作为轮换备份,因此当出现大量对象在Minor GC后仍然存活的情况时(最极端就是内存回收后新生代中所有对象都存活),就需要老年代进行分配担保,让Survivor	无法容纳的对象直接进入老年代.与生活中的贷款担保类似,老年代要进行这样的担保,前提是老年代本身还有容纳这些对象的	剩余空间,一共有多少对象会活下来,在实际完成内存回收之前是无法明确知道的,所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值,与老年代的剩余空间进行比较,决定是否进行Full GC来让老年代腾出更多空间.

取平均值进行比较其实仍然是一种动态概率的手段,也就是说如果某次Minor GC存活后的对象突增,远远高于平均值的话,依然会导致担保失败(Handle Promotion Failure).如果出现了HandlePromotionFailure失败,	那就只好在失败后重新发起一次Full GC.虽然担保失败时绕的圈子是最大的,但大部分情况下都还是会将	HandlePromotionFailure开关打开,避免Full GC过于频繁,

示例代码
```java
	private static final int _1MB = 1024 #### 1024;

	/**
	  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M
	  * -XX:SurvivorRatio=8 -XX:-HandlePromotionFailure
	  */
	@SuppressWarnings("unused")
	public static void testHandlePromotion() {
		 byte[] allocation1, allocation2, allocation3,
		 allocation4, allocation5, allocation6, allocation7;
		 allocation1 = new byte[2 #### _1MB];
		 allocation2 = new byte[2 #### _1MB];
		 allocation3 = new byte[2 #### _1MB];
		 allocation1 = null;
		 allocation4 = new byte[2 #### _1MB];
		 allocation5 = new byte[2 #### _1MB];
		 allocation6 = new byte[2 #### _1MB];
		 allocation4 = null;
		 allocation5 = null;
		 allocation6 = null;
		 allocation7 = new byte[2 #### _1MB];
	}
```


### java堆溢出
溢出代码

```java
  public class HeapOOM {

	static class OOMObject {
	}

	/**
	 * -verbose:gc -Xms20M -Xmx20M -Xmn10M
	 * -XX:PrintGCDetails
	 * -XX:SurvivorRatio=8
	 * @param args
	 */
	public static void main(String[] args) {
		List<OOMObject> list = new ArrayList<>();
		while(true) {
			list.add(new OOMObject());
		}
	}

}
```
执行代码
```
	javac HeapOOM.java
	java -verbose:gc -Xms20M -Xmx20M -Xmn10M   -XX:+PrintGCDetails  -XX:SurvivorRatio=8  HeapOOM
	pause
```
解决java堆内存溢出,一般的手段是通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出的堆转储快照进行分析.重点是确认内存中的对象是否是必要的,也就是先分清楚是内存泄漏还是内存溢出.
1. 如果是内存泄漏可通过工具查看泄漏对象到GC Roots的引用链.于是就能找到泄漏对象是通过怎样的路径与GC Toots相关联,并导致垃圾收集器无法自动回收它们的. 掌握了泄漏对象的类型信息,以及GC Roots引用链信息,就可以比较准确地定位出泄漏代码的位置.
2. 如果不存在泄漏, 换句话说就是内存中的对象确实还都必须存货着, 那就应当检查虚拟机的堆参数,与物理机内存对比查看是否还可以调大,从代码上检查是否存在某些生命周期过长,持有状态时间过长的情况,尝试减少程序运行周期的内存消耗.

### 虚拟机栈和本地方法栈溢出
溢出代码
```java
/**
  * -Xoss 设置本地放发栈 但是此参数无效
  * -Xss 虚拟机栈 设置此参数
  * @param args
  */

public class JavaVMStackSOF {

	private int stackLength = 1;

	public void stackLeak() {
		stackLength ++;
		stackLeak();
	}


	public static void main(String[] args) {
		JavaVMStackSOF oom = new JavaVMStackSOF();
		try {
			oom.stackLeak();
		} catch(Throwable e) {
			System.out.println("stack length:" + oom.stackLength);
			throw e;
		}
	}
}

public class JavaVMStackOOM {
	private void dontStop() {
		while(true) {

		}
	}

	public void stackLeakByThread() {
		while(true) {
			Thread t = new Thread(new Runnable(){
				@Override
				public void run() {
					dontStop();
				}
			});
		}
	}

	public static void main(String[] args) {
		JavaVMStackOM om = new JavaVMStackOM();
		om.stackLeakByThread();
	}
}
```
以上俩个实现都都无法让虚拟机产生OutOfMemoryError异常,只能产生StackOverflowError.实验结果表明: 单个线程下,无论由于栈帧太大还是虚拟机容量太小,当内存无法分配时,虚拟机抛出的都是StackOverflowError.如果测试时不是限于单线程,通过不断建立新线程的方式倒是可以产生内存溢出异常. 但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系,或者准确说,在这种情况下,给每个线程的栈分配的内存越大,反而越容易产生内存溢出异常.

当开发多线程应用时应该特别注意的是,出现StackOverflowError异常时有错误堆栈可以阅读,相对来说比较容易找到问题.如果使用虚拟机默认参数,栈深度在大多数情况下达到1000-2000完全没有问题,对于正常的方法调用(包括递归),这个深度应该够用了,但是如果建立过多的线程导致的内存溢出,在不能减少线程数或者更换64位虚拟机的情况下,就只能通过减少最大堆和减少栈容量来换取更多的线程.

### 运行时常量池溢出

溢出代码
```java
/**
 * 运行时常量溢出
 * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M
 * @author mingwang
 *
 */
public class RuntimeConstantPoolOOM {

	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		int i = 0;
		while(true) {
			list.add(String.valueOf(i++).intern());
		}
	}
}
```
如果想运行时常量池添加内容最简单的方式就是String.intern()这个native方法.该方法的作用是:如果池中已经包含一个等于此String对象的字符串,则返回池中这个字符串的String对象.否则将次String对象包含的字符串添加到常量池中,并返回次String对象音乐.

### 方法区溢出

```java
	/**
	 * 借助CGLib使得方法区内存溢出异常
	 * -XX:PermSize10M -XX:MaxPermSize10M
	 * @author mingwang
	 *
	 */
	public class JavaMethodAreaOOM {

		public static void main(String[] args) {
			while(true) {
				Enhancer enhancer = new Enhancer();
				enhancer.setSuperclass(OOMObject.class);
				enhancer.setUseCache(false);
				enhancer.setCallBack(new MethodInterceptor(){
					public Object intercept(Object obj, Method method, Object[] objs,
					MethodProxy proxy) throws Throwable {
						return proxy.invokeSuper(obj, args);
					}
				});
			}
		}

		static class OOMObject {

		}
	}
```
执行代码
```
	javac JavaMethodAreaOOMRun.java
	java -XX:PermSize10M -XX:MaxPermSize10M JavaMethodAreaOOMRun
pause
```
方法区用于存放Class信息,为了测试这个区域,基本思路是产生大量的类去填充方法区,直到溢出.本例中使用的是CGLib, 还可以使用ASM等框架进行测试.方法区溢出也是一种常见的内存溢出异常.一个类如果被垃圾收集器回收,其条件是非常苛刻的. 在经常动态生成大量Class的应用中,需要特别注意类的回收状况. (基于OSGI的应用即使是同一个类文件被不同的加载器加载也会视为不同的类)


### 本地内存直接溢出
溢出代码
```java
	/**
	 * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M
	 */
	public class DirectMemoryOOM {
	    private static final int _1MB = 1024 * 1024;

	    public static void main(String[] args) throws Exception {
	        Field unsafeField = Unsafe.class.getDeclaredFields()[0];
	        unsafeField.setAccessible(true);
	        Unsafe unsafe = (Unsafe)unsafeField.get(null);
	        while(true)
	            unsafe.allocateMemory(_1MB);
	    }
}
```
直接通过反射获取Unsafe实例并进行内存分配,Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例,也就是设计者希望只有rt.jar中的类才能使用unsafe的功能. 因为虽然使用DirectbyeBuffer分配内存也会抛出内存异常,但抛出异常时并没有真正向操作系统申请分配内存,而是通过计算得知内存无法分配,于是手动抛出异常,真正申请分配内存的方法是:unsafe.allocateMemory(_1MB);
