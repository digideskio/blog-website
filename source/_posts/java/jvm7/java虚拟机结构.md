category: java
tag: jvm7
title: 运行时数据区
---
## 运行时数据区
### PC寄存器 (线程独有)
* 每一个虚拟机线程都有自己的线程寄存器
* 寄存器里存储了java虚拟机正在执行的字节码指令(线程当前方法)的地址, 字节码解释器工作时就是通过改变这个计数器的值来选取下一条
  需要执行的字节码指令,分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成
* 由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方法来实现的,在任何一个确定的时刻,一个处理器只会执行一条线程   中的指令.因此为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程之间的计数器互不影响,独立
  存储,称这类内存区域为"线程私有"的内存
* 这是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域.

寄存器集成在 CPU 里面,这是最快的数据访问存储区,但是寄存器的数量极其有限,所以寄存器由编译器根据需求进行分配,开发人员不能直接控制,也不能在程序中感觉到寄存器存在的迹象 。

### java虚拟机栈 (线程独有)
* 与线程同时创建,用于存储栈帧. 它的生命周期与线程相同.
* 每个方法被执行的时候都会创建一个栈帧,用于存储局部变量表,操作数栈,动态连接,方法出口等信息.
* 在java虚拟机中.对这个区域规定了俩种异常情况:

   > 1. 如果请求的栈深度大于虚拟机所允许的深度,抛出StackOverflowError.<br>
   > 2. 如果虚拟机可以动态扩展,当拓展时无法申请到足够的内存时会抛出OutOfMemoryError异常

位于通用 RAM 中,存放基本类型的数据和对象的引用,但对象本身不存放在栈中,而是存放在堆中 。 在堆中产生了一个数组或对象后,还可以在栈中定义一个特殊的变量,让栈中这个变量的取值等于数组或对象在堆内存中的首地址,栈中的这个变量就成了数组或对象的引用变量 。

### java堆
* 是供各个线程共享的运行时内存
* 所有类实例和数组对象分配内存的地方
* 在虚拟机创建的时候该区域就创建了
* 存储了内存管理系统(GC)
* java虚拟机中规定,java堆可以处于物理上不连续的内存空间中,逻辑上是连续的即可.在设计时,既可以设计成固定大小的,也可以设计成
  可拓展的.
* 如果在堆内中没有内存完成实例分配,而且堆无法再拓展时,会抛出OutOfMemoryError
* 需要说明的一点的是,随着JIT编译器的发展和逃逸分析技术的逐渐成熟,栈上分配,标量替换优化技术将会导致一些变化,所有的对象在堆上
  分配也不是那么绝对了

  > 简单介绍一下,java堆内部分配: 由于现在GC收集器基本都是采用的分代收集算法,所以java堆还可以细分为:新生代和老年代.分的再细一点还有Eden空间,From Survivor空间,To Sruvivor空间. 如果从内存分配的角都看,线程共享的java对可能还可能划分出多个线程私有的分配缓冲区.

一种通用性的内存池 (也存在于 RAM 中)， 用于存放所以的 JAVA 对象。 Java 的堆是一个运行时数据区 , 对象被存储在堆中 。 这些对象通过 new 等指令建立， 它们不需要程序代码 来显式的释放。 因此， 在堆里分配存储有很大的灵活性 。 堆的缺点是,由于要在运行时动态分配内存,存取速度较慢 。

### 方法区
* 虚拟机启动时创建
* 供各个线程共享的运行时内存
* 存储了每个类的结构信息, 运行时常量池, 静态变量,即时编译器编译后的代码, 方法数据, 构造函数, 普通方法的字节码内容
* java虚拟机规范对这个区域的限制非常宽松,除了和java堆一样不需要连续的内存外,和可以实现固定大小或者可拓展的之外,还可以
  选择不实现垃圾收集.(在HotSop虚拟机中一般喜欢称这个区域为永久代)并非数据进入永久代就像其名字一样"永久存在". 这个区域的
  回收目标是针对常量池的回收和对类型的卸载.
* 当方法区无法满足内存分配需求时,将抛出OutOfMemoryError.

###### 运行时常量池

运行时常量池是方法区的一部分.

Class文件中除了有类的版本,字段,方法,接口等信息外,还有一项信息是常量池,用于存储编译器产生的各种字面量和符号引用.
这部分内容将在类加载后存放到方法区的运行时常量池中.

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性,java语言并不要求常量一定只能在编译器产生,也就是并非预置入Class文件常量池的内容才能进入方法区运行时常量池,运行期间也可能将新的常量放入常量池,这种特性被用到比较多的便是`String#intern()`在加载类和接口到虚拟机后就创建对应的常量池,其是Class文件中每个类或者接口常量池表的运行时表示.

它包含了从编译期克制的数值字面量到必须到运行期解析后才能获得的方法或字段引用

java 中的常量池,是为了方便快捷地创建某些对象而出现的,当需要一个对象时,就可以从池中取一个出来(如果池中没有则创建一个)， 则在需要重复创建相等变量时节省了很多时间 。 常量池其实也就是一个内存空间,不同于使用 `new` 关键字创建的对象所在的堆空间 。 常量池用来存放在编译期间就可以确定的数据,比如字符串等类型


###### 回收方法区
在新生代,常规应用进行一次垃圾收集,一般可以收回70%-95%的空间,而永久代(方法区)远低于此.

###### 永久代的垃圾回收主要是回收俩部分内容:
*. 废弃常量

回收废弃常量与回收java堆中的对象非常类似.以常量池字面量回收为例,如果一个字符串"ABC"已经进入了常量池,但是当前系统中没有任何一个String对象是叫做"ABC"的,换句话说也就是没有任何String对象引用这个字面量,也没有其他地方引用这个字面量,如果这个时候发生内存回收,而且必要的话,这个"ABC"常量会被清除出常量池.常量池中的其他类(皆苦),方法,字段的符号引用也与此类似.

* 无用的类

判断一个类是否是无用的类条件要苛刻的多. 要同时满足下面三个条件:

	> 1. 该类的所有实例都已经被回收,也就是java堆中不存在该类的实例.<br.>
	> 2. 加载该类的ClassLoader已经被回收.<br.>
	> 3. 该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类.

虚拟机可以对满足上面三个条件的类进行回收,这里说的仅仅是可以,而不是和对象一样,不使用了就必然回收.是否对类进行回收HotSpot虚拟机提供了-Xnoclassgc参数进行控制,还可以使用`-verbose:Class`及
`-XX:+TraceClassLoading`,`-XX:+TraceClassUnLoading`查看类的加载和卸载信息.`-verbose:Class`和`-XX:+TraceClassLoading`可以在Product版的虚拟机中使用,但是`-XX:+TraceClassLoading`参数需要fastdebug版的虚拟机支持

### 直接内存
* 直接内存并不是虚拟机运行时数据区的一部分,也不是java虚拟机规范中定义的内存区域,但是这部分内存也被频繁使用,而且也会导致
  OutOfMemoryError异常出现
* 在JDK1.4引入的NIO类,一种基于通道与缓冲区的I/O方式,它可以利用Native函数库直接分配堆外内存,然后通过一个存储在java堆里面的
  DirectByteBuffer对象作为这块内存的引用进行操作.这样能在一些场景中显著提高性能,因为避免了java堆和Native堆中来回复制数据.
* 显然本机直接内存的分配不会收到java堆大小的限制,但是既然是内存,则肯定会收到本机总内存(包括RAM及SWAP区或者分页文件)及处理器
  寻址空间的限制.一般在配置虚拟机参数时,会genuine实际内存设置-Xmx等参数信息,但经常会忽略掉直接内存,使得各个区域的总和大于
  物理内存限制,从而导致动态拓展时,出现OutOfMemoryError.

### 本地方法栈
* 用来支持native方法

### 静态存储

静态存储里存放程序运行时一直存在的数据 。 可用关键字 static 来标识一个对象的特定元素是静态的,被static 修饰的成员变量和成员方法独立于该类的任何对象,它不依赖类特定的实例,被类的所有实例共享 。 但 JAVA 对象本身不会存放在静态存储空间里,而只是把对象中的一些特殊元素放置这里 。

## 栈帧
* 用来存储数据和部分过程结果的数据结构, 同时也用来处理动态连接, 方法返回值和异常分派
* 随着方法的调用而创建,随着方法的调用结束而销毁. (结束也包含异常情况)
* 其内存分配在虚拟机栈之中, 每一个栈帧都有自己的本地变量表, 操作数栈, 和指向当前方法所属的类的运行时常量池.

### 局部变量表
* 其长度在编译器决定
* 一个局部变量可以保存boolean, byte, char, short, int, float, reference,returnAddress类型的数据.俩个局部变量可以
  保存一个long或者double类型的变量.
* java虚拟机使用局部变量表来完成方法调用时的参数传递. 当调用一个方法时, 它的参数将会传递至从0开始的连续的变量表位置上.
* 当调用一个实例方法时,第0个局部变量一定是用来存储被调用的实例方法所在的对象的引用.后续的其他参数将会传递至从1开始的连续的
  局部变量表位置上
* 虚拟机通过索引定位的方式使用局部变量表,索引值的范围是从0开始到局部变量表最大的Slot数量.
```
	局部变量表中的Slot是可重用的,方法体定义的变量,其作用域并不一定会覆盖整个方法体,如果当前字节码PC计数器的值
	已经超出了某个变量的作用域,那么这个变量对应的Slot就可以交给其他变量使用. 这样的设计不仅仅是为了节省栈空间,
	在某些情况下Slot的复用会直接影响到系统的垃圾收集行为
```
```java
public class CollectSlot1 {

    public static void main(String[] args) {
        byte[] placeholder = new byte[64 * 1024 * 1024];
        System.gc();
    }
}

public class CollectSlot2 {

    public static void main(String[] args) {
        {
            byte[] placeholder = new byte[64 * 1024 * 1024];
        }
        System.gc();
    }
}

public class CollectSlot3 {

    public static void main(String[] args) {
        {
            byte[] placeholder = new byte[64 * 1024 * 1024];
        }
        int a = 0;
        System.gc();
    }
}

public class CollectSlot4 {

    public static void main(String[] args) {
        int a = 0;
        System.gc();
    }
}

运行时,加上 -verbose:gc 参数,来查看垃圾收集过程.
```
###### 运行结果,CollectSlot1和CollectSlot2并没有执行垃圾回收. 而CollectSlot3却执行了垃圾收集
###### 运行分析

placeholder能否被回收的根本原因就是:局部变量表中的Slot是否还存有关于placeholder数组对象的引用.在CollectSlot2中,代码虽然已经离开了placeholder的作用域,但在此之后,没有任何局部变量表的读写操作,placeholder原本所占用的Slot还没有被其他变量所复用,所以作为GC Roots一部分的局部变量表仍然保持着对它的关联.

这种关联没有被及时打断,在绝大部分情况下影响都很轻微.但如果遇到一个方法,其后面的代码有一些耗时很长的操作,而前面又定义了占用了大量内存,实际上已经不会再被使用的变量,手动将其设置为null值就不是一个毫无意义的操作.

这种操作可以作为一种在极特殊情景(对象内存占用大,此方法的栈帧长时间不能被回收,方法调用次数达不到JIT的编译条件)下的奇技来使用. 但不应当对赋null值操作有过多的依赖.

应该以恰当的作用域来控制变量回收时间才是最优雅的解决方法.(如CollectSlot3)

另外赋null值的操作在经过虚拟机JIT编译器优化之后会被消除掉,这时候将变量设置为null实际上是没有意义的.字节码被编译为本地代码后,对GC Roots的枚举也与解释执行时期有所差别,CollectSlot2在经过JIT编译后,System.gc() 执行时就可以正确回收掉内存,而无需写成CollectSlot3

关于局部变量表,还有一点可能会对实际开发产生影响,就是局部变量表不像前面介绍的类变量那样存在"准备阶段".类变量有俩次赋初始值的过程,一次在准备阶段,赋予系统初始值.另外一次在初始化阶段,赋予程序员定义的初始化. 因此即使在初始化阶段程序员没有为类变量赋值也没关系,类变量仍然具有一个确定的初始值. 但是局部变量就不一样了,如果一个局部变量定义了但没有赋初始值是不能使用的. 所以 CollectSlot4 并不能运行,编译器能在编译器期间检查并提示这一点.

### 操作数栈
* 每个栈帧内部都包含一个称为操作数栈先进后出栈.
* 其栈帧长度在编译器决定.
* 栈帧在刚创建的时候, 操作数栈是空的, java虚拟机提供了一系列指令从局部变量表或者对象实例的字段中复制常量或变量值到操作数栈中.
* 也提供了一些列指令从操作数栈取走, 操作数据, 以及把结果重新入栈
* 在调用方法时, 操作数栈也用来准备调用方法的参数以及接受方法返回结果.
* 每个操作数栈的位置可以保存一个java虚拟机定义的任意数据类型的值,包括long和double类型
* 在任意时刻,操作数都会有一个确定的栈深度, 一个long或者double类型的数据会占用俩个单位的栈深度, 其他类型占用一个单位的栈深度

操作数栈也称为操作栈,它是一个先入后出栈.同局部变量表一样,操作数栈的最大深度也是在编译的时候被写入到Code属性的max_stacks数据项之中的.操作数栈的每一个元素都可以是任意的java数据类型,包括long和double. 32位的数据类型所占的栈容量为1,64位数据类型所占的栈容量为2.在方法执行的时候,操作数栈的深度都不会超过在max_stacks数据项中设定的最大值.

当一个方法开始执行的时候,这个方法的操作数栈是空的,在方法的执行过程中,会有各种字节码指令向操作数栈写入和提取内容,也就是入栈和出栈操作.例如:在做算术运算的时候是通过操作数栈来进行的,又或者在调用其他方法的时候是通过操作数栈来进行参数传递的.

举个例子,整数加法的字节码指令iadd在运行的时候要求操作数栈中最接近栈顶的俩个元素已经存入了俩个int型的数值,当执行这个指令时,会将这俩个int值出栈并相加,然后将相加的结果入栈.

操作数栈元素的数据类型必须与字节码指令的序列严格匹配,在编译程序代码的时候,编译器要严格保证这一点,在类校验阶段的数据流分析中还要再次验证这一点.再以上的iadd指令为例,这个指令用于整数相加,它在执行时,最接近栈顶的俩个元素的类型必须是int性,不能出现一个long和一个float使用iadd命令相加的情况.

另外,在概念模型中,俩个栈帧为虚拟机栈的元素,相互之间是完全独立的.但是大多数虚拟机的实现里都会做一些优化处理,令俩个栈帧出现一部分重叠.让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起,这样在进行方法调用时就可以共有一部分数据,而无需进行额外的参数复制传递:

![俩个栈帧之间的数据共享]()

java虚拟机解释执行引擎称为"基于栈的执行引擎",其中所指的栈就是操作数栈.


### 动态连接
* 每个栈帧内部都包含一个指向运行时常量池的引用来支持当前方法的代码实现动态连接.
* 在Class文件中,描述一个方法调用其他方法,或者访问其他成员变量是通过符号引用来表示的.动态连接就是将这些符号引用所表示的方法转换为实际方法的直接引用.
* 类加载的过程中将要解析尚未被解析的符号引用, 并且将变量访问转换为访问这些变量的存储结构所在的运行时内存位置的正确偏移量.
* 由于动态连接的存在,通过晚期绑定使用的其他类的方法和变量在发生变化时,将不会对调用他们的方法构成影响

每个栈帧都包含一个指向运行时常量池中该栈帧所属的方法引用,持有这个引用是为了支持调用过程中的`动态连接`.Class文件的常量池中存有大量的符号引用,字节码中的方法调用指令就以常量池中指向方法的符号引用为参数. 这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用,这种转化称为静态解析. 另外一部分将在每一次的运行期间转化为直接引用,这部分称为动态连接

### 方法正常调用完成
* 当前栈帧承担着恢复调用者状态的责任, 其状态包括调用这的局部变量表, 操作数栈以及被正确增加用来表示执行了该方法调用指令的程序计数器等
* 使得调用者的代码能在被调用的方法返回并且返回值被压入调用者栈帧的操作数栈后继续正常执行

### 方法调用非正常完成
* 指的是在方法调用过程了,某些指令导致了虚拟机抛出异常,而且虚拟机抛出的异常在该方法中没办法处理,或者在执行过程中遇到athrow字节码指令抛出的显式异常,同时在方法内部没有捕获异常


### 方法返回地址

当一个方法执行后,有俩个方式退出这个地址.第一种方式是执行引擎遇到任意一个方法返回的字节码指令,这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为调用者),是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定,这种退出方法的方式为正常完成出口.

另一种退出的方法是,在方法执行过程中遇到了异常,并且这个异常没有在方法体内得到处理,无论虚拟机内部产生的异常,还是代码中使用athrow字节码之类产生的异常,只要在本方法的异常表中没有搜索到匹配的异常处理器,就会导致方法退出,这种退出方法的方式称为异常完成出口.一个方法使用异常完成出口的方式退出,是不会给它的上层调用者产生任何返回值的.

无论采用何种退出方法,在方法退出之后,都需要返回到方法被调用的位置,程序才能继续执行,方法返回时可能需要在栈帧中保存一些信息,用来帮助恢复它的上层方法的执行状态.一般来说,方法正常退出时,调用者的PC计数器的值就可以作为返回地址,栈帧中很可能会保存这个计数器值.而方法异常退出时,返回地址是要通过异常处理器表来确定的,栈帧中一般不会保存这部分信息.

方法退出的过程实际上等同于把当前栈帧出栈,因此退出时可能执行的操作有:回复上层方法的局部变量表和操作数栈,把返回值(如果有的话)压入调用者栈帧的操作数栈中,调整PC计数器的值以执行方法调用指令后面的一条指令等.

## 方法调用
方法调用并不等于方法执行,方法调用阶段唯一的任务就是确定方法的版本号(即调用哪个方法),暂时还不涉及方法内部的具体运行过程.在承运运行时,进行方法调用是最普遍,最频繁的的操作,单前面已经讲过,Class文件的编译过程中不包含传统编译的连接步骤,一切方法调用在Class文件里面存储的都只是符号引用,而不是方法在实际运行时内存布局中的入口地址(相当于之前的所说的直接引用).这个特性给java带来了更加强大的动态拓展能力,但也使得java方法的调用过程变得相对复杂起来,需要在类加载期间甚至到运行期间才能确定目标方法的直接引用.

### 解析
继续前面关于方法调用的话题,所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用,在类加载的解析极端,会将其中的一部分符号引用转化为直接引用,这种解析能够成立的前提是:方法在程序真正运行之前就有一个可确定的调用版本,并且这个方法在运行期是不可改变的.换句话说,调用目标在程序代码写好,编译器进行编译时就必须确定下来.这类方法的调用称为`解析(Resolution)`.

在java语言中,符合"编译器可知,运行期不可变"这个要求的方法主要是有静态方法和私有方法俩大类,前者与类型直接关联,后者在外部不可被访问,这俩种方法都不可能通过继承或别的方式重写出其他版本,因此他们都适合在类加载阶段进行解析.

###### 与之对应的是,在java虚拟机里面提供了四条方法调用字节码指令:
* `invokestatic`: 调用静态方法
* `invokespecial`:调用实例构造器`<init>`方法,私有方法和父类方法
* `invokevirtual`:调用所有的虚方法
* `invokeinterface`:调用接口方法,会在运行时再确定一个实现此接口的对象

只要能被`invokestatic`, `invokespecial`指令调用的方法,都可以在解析阶段确定唯一的版本,符合这个条件的有静态方法,私有方法,实例构造器和父类方法四类,他们在类加载的时候就会把符号引用解析为该方法的直接引用.这些方法可以称为`非虚方法`,与此相反,其他方法就称为`虚方法`(除了final方法).下面的例子中最常见的解析调用的例子,此样例中,静态方法`sayHello()`只可能属于类型`StaticResolution`,没有任何手段可以覆盖或者隐藏这个方法.

```java
public class StaticResolution {

    public static void sayHello() {
        System.out.println("hello");
    }

    public static void main(String[] args) {
        StaticResolution.sayHello();
    }
}

```
通过javap查看字节码:
```java
public static void main(java.lang.String[]);
   descriptor: ([Ljava/lang/String;)V
   flags: ACC_PUBLIC, ACC_STATIC
   Code:
     stack=0, locals=1, args_size=1
        0: invokestatic  #5                  // Method sayHello:()V
        3: return
     LineNumberTable:
       line 9: 0
       line 10: 3

```

java中的非虚方法除了使用`invokestatic`和`invokespecial`调用的方法之外还有一种,就是被`final`修饰的方法.虽然`final`方法是使用`invokespecial`指令来调用的,但是由于它无法被覆盖,没有其他版本,所以也无须对方法接受者进行多态选择,又或者说多态选择的结果是唯一的.在java语言规范中明确说明了final方法是一种非虚方法.

解析调用一定是个静态过程,在编译期间就完全确定,在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用,不会延迟到运行期再去完成.而分派调用则可能是静态的也可能是动态的,根据分派依据的宗数量可分为单分派和多分派.这俩类分派方式俩俩组合就构成了静态单分派,静态多分派,动态单分派,动态多分派.









