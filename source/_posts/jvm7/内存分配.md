category: jvm7
date: 2014-10-08
title: 内存分配
---
## 内存分配
#### 对象优先在Eden分配

大多数情况下,对象在新生代`Eden`区中分配.当`Eden`区没有足够的空间进行分配时,虚拟机将发起一次`Minor GC`.

虚拟机提供了`-XX:+PrintGCDetails`这个收集器日志参数,告诉虚拟机在发生垃圾收集行为时打印内存回收日志,并且在进程退出的时候输出当前内存各区域的分配情况.在实际应用中,内存回收日志一般是打印到文件后通过日志工具进行分析.

1. 新生代GC(`Minor GC`)：指发生在新生代的垃圾收集动作,因为Java对象大多都具备朝生夕灭的特性,所以`Minor GC`非常频繁,一般回收速度也比较快.
2. 老年代GC(`Major GC/Full GC`)：指发生在老年代的GC,出现了Major GC,经常会伴随至少一次的Minor GC(但非绝对的,在ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程).MajorGC的速度一般会比Minor GC慢10倍以上.

###### 示例代码
```java
private static final int _1MB = 1024 #### 1024;

/**
  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
  */
public static void testAllocation() {
	    byte[] allocation1, allocation2, allocation3, allocation4;
	    allocation1 = new byte[2 #### _1MB];
	    allocation2 = new byte[2 #### _1MB];
	    allocation3 = new byte[2 #### _1MB];
	    allocation4 = new byte[4 #### _1MB];  // 出现一次Minor GC
}
```
###### 代码分析

`testAllocation()`方法中,尝试分配3个2MB大小和1个4MB大小的对象, 在运行时通过`-Xms20M、 -Xmx20M`和`-Xmn10M`这3个参数限制Java堆大小为20MB,且不可扩展,其中10MB分配给新生代,剩下的10MB分配给老年代.

`-XX:SurvivorRatio=8`决定了新生代中Eden区与一个`Survivor`区的空间比例是8比1,从输出的结果也能清晰地看到`“eden space 8192K、from space 1024K、to space 1024K”`的信息,新生代总可用空间为`9216KB`(`Eden`区+1个`Survivor`区的总容量).

执行`testAllocation()`中分配`allocation4`对象的语句时会发生一次Minor GC,这次GC的结果是新生代6651KB变为148KB,而总内存占用量则几乎没有减少(因为allocation1、2、3三个对象都是存活的,虚拟机几乎没有找到可回收的对象).

这次GC发生的原因是给allocation4分配内存的时候,发现Eden已经被占用了6MB,剩余空间已不足以分配allocation4所需的4MB内存,因此发生Minor GC.GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间(Survivor空间只有1MB大小),所以只好通过分配担保机制提前转移到老年代去.

这次GC结束后,4MB的allocation4对象被顺利分配在Eden中.因此程序执行完的结果是Eden占用4MB(被allocation4占用),Survivor空闲,老年代被占用6MB(被allocation1、2、3占用).通过GC日志可以证实这一点.

#### 大对象直接进入老年代

所谓大对象就是指,需要大量连续内存空间的Java对象,最典型的大对象就是那种很长的字符串及数组(笔者例子中的byte[]数组就是典型的大对象).大对象对虚拟机的内存分配来说就是一个坏消息(替Java虚拟机抱怨一句,比遇到一个大对象更加坏的消息 就是遇到一群“朝生夕灭”的“短命大对象”,写程序的时候应当避免),经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们.

虚拟机提供了一个`-XX:PretenureSizeThreshold`参数,令大于这个设置值的对象直接在老年代中分配.这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝(复习一下：新生代采用复制算法收集内存).

执行代码清单3-4中的`testPretenureSizeThreshold()`方法后,我们看到Eden空间几乎没有被使用,而老年代10MB的空间被使用了40%,也就是4MB的allocation对象直接就分配在老年代中,这是因为`PretenureSizeThreshold`被设置为3MB(就是3145728B,这个参数不能与`-Xmx`之类的参数一样直接写3MB),因此超过3MB的对象都会直接在老年代中进行分配.

> 注意　`PretenureSizeThreshold`参数只对Serial和ParNew两款收集器有效,`Parallel Scavenge`收集器不认识这个参数,
>
> `Parallel Scavenge`收集器一般并不需要设置.如果遇到必须使用此参数的场合,可以考虑ParNew加CMS的收集器组合.

###### 示例代码
```java
	private static final int _1MB = 1024 #### 1024;

	/**
	  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
	  * -XX:PretenureSizeThreshold=3145728
	  */
	public static void testPretenureSizeThreshold() {
		　byte[] allocation;
		　allocation = new byte[4 #### _1MB];  //直接分配在老年代中
	}
```
#### 长期存活的对象将进入老年代

虚拟机既然采用了分代收集的思想来管理内存,那内存回收时就必须能识别哪些对象应当放在新生代,哪些对象应放在老年代中.为了做到这点,虚拟机给每个对象定义了一个对象年龄(Age)计数器.如果对象在Eden出生并经过第一次Minor GC后仍然存活,	并且能被Survivor容纳的话,将被移动到Survivor空间中,并将对象年龄设为1.对象在Survivor区中每熬过一次Minor GC,年龄就增加1岁,当它的年龄增加到一定程度(默认为15岁)时,就会被晋升到老年代中.对象晋升老年代的年龄阈值,可以通过参数`-XX:MaxTenuringThreshold`来设置.

读者可以试试分别以`-XX:MaxTenuringThreshold=1`和`-XX:MaxTenuringThreshold=15`两种设置来执行代码清单3-5中的`testTenuringThreshold()`方法,此方法中allocation1对象需要256KB的内存空间,Survivor空间可以容纳.当MaxTenuringThreshold=1时,allocation1对象在第二次GC发生时进入老年代,新生代已使用的内存GC后会非常干净地变成0KB.而MaxTenuringThreshold=15时,第二次GC发生后,allocation1对象则还留在新生代Survivor空间,这时候新生代仍然有404KB的空间被占用.

###### 实例代码
```java
	private static final int _1MB = 1024 #### 1024;

	/**
	  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M
	  * -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1
	  * -XX:+PrintTenuringDistribution
	  */
	@SuppressWarnings("unused")
	public static void testTenuringThreshold() {
		 byte[] allocation1, allocation2, allocation3;
		 allocation1 = new byte[_1MB / 4];
		  // 什么时候进入老年代取决于XX:MaxTenuringThreshold设置
		 allocation2 = new byte[4 #### _1MB];
		 allocation3 = new byte[4 #### _1MB];
		 allocation3 = null;
		 allocation3 = new byte[4 #### _1MB];
	}
```
#### 动态年龄判断

为了能更好地适应不同程序的内存状况,虚拟机并不总是要求对象的年龄必须达到`MaxTenuringThreshold`才能晋升老年代,如果在`Survivor`空间中相同年龄所有对象大小的总和大于`Survivor`空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代,无须等到`MaxTenuringThreshold`中要求的年龄.

执行代码清单3-6中的testTenuringThreshold2()方法,并设置参数`-XX: MaxTenuringThreshold=15`,会发现运行结果中`Survivor`的空间占用仍然为0%,而老年代比预期增加了`6%`,也就是说`allocation1、allocation2`对象都直接进入了老年代,而没有等到15岁的临界年龄.因为这两个对象加起来已经达到了512KB,并且它们是同年的,满足同年对象达到Survivor空间的一半规则.我们只要注释掉其中一个对象的new操作,就会发现另外一个不会晋升到老年代中去了.

###### 示例代码
```java
	private static final int _1MB = 1024 #### 1024;

	/**
	  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M
	  * -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15
	  * -XX:+PrintTenuringDistribution
	  */
	@SuppressWarnings("unused")
	public static void testTenuringThreshold2() {
		 byte[] allocation1, allocation2, allocation3, allocation4;
		 allocation1 = new byte[_1MB / 4];
		  // allocation1+allocation2大于survivor空间的一半
		 allocation2 = new byte[_1MB / 4];
		 allocation3 = new byte[4 #### _1MB];
		 allocation4 = new byte[4 #### _1MB];
		 allocation4 = null;
		 allocation4 = new byte[4 #### _1MB];
	}
```
#### 空间分配担保

在发生Minor GC时,虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小,如果大于,则改为直接进行一次Full GC.如果小于,则查看HandlePromotionFailure设置是否允许担保失败;如果允许,那只会进行Minor GC;如果不允许,则也要改为进行一次Full GC.

前面提到过,新生代使用复制收集算法,但为了内存利用率,只使用其中一个Survivor空间来作为轮换备份,因此当出现大量对象在Minor GC后仍然存活的情况时(最极端就是内存回收后新生代中所有对象都存活),就需要老年代进行分配担保,让Survivor	无法容纳的对象直接进入老年代.与生活中的贷款担保类似,老年代要进行这样的担保,前提是老年代本身还有容纳这些对象的	剩余空间,一共有多少对象会活下来,在实际完成内存回收之前是无法明确知道的,所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值,与老年代的剩余空间进行比较,决定是否进行Full GC来让老年代腾出更多空间.

取平均值进行比较其实仍然是一种动态概率的手段,也就是说如果某次Minor GC存活后的对象突增,远远高于平均值的话,依然会导致担保失败(Handle Promotion Failure).如果出现了HandlePromotionFailure失败,	那就只好在失败后重新发起一次Full GC.虽然担保失败时绕的圈子是最大的,但大部分情况下都还是会将	HandlePromotionFailure开关打开,避免Full GC过于频繁,

###### 示例代码
```java
	private static final int _1MB = 1024 #### 1024;

	/**
	  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M
	  * -XX:SurvivorRatio=8 -XX:-HandlePromotionFailure
	  */
	@SuppressWarnings("unused")
	public static void testHandlePromotion() {
		 byte[] allocation1, allocation2, allocation3,
		 allocation4, allocation5, allocation6, allocation7;
		 allocation1 = new byte[2 #### _1MB];
		 allocation2 = new byte[2 #### _1MB];
		 allocation3 = new byte[2 #### _1MB];
		 allocation1 = null;
		 allocation4 = new byte[2 #### _1MB];
		 allocation5 = new byte[2 #### _1MB];
		 allocation6 = new byte[2 #### _1MB];
		 allocation4 = null;
		 allocation5 = null;
		 allocation6 = null;
		 allocation7 = new byte[2 #### _1MB];
	}
```























