category: Java
tag: Netty
date: 2016-01-23
title: Netty 内置解码器
---
为了解决网络数据流的拆包粘包问题,Netty为我们内置了如下的编码解码器
* LineBasedFrameDecoder
* StringDecoder
* DelimiterBasedFrameDecoder
* FixedLengthFrameDecoder
* ProtoBufVarint32FrameDecoder
* ProtobufDecoder
* ProtobufEncoder
* LengthFieldBasedFrameDecoder
* ByteToMessageDecoder


## LineBasedFrameDecoder
`LineBasedFrameDecoder`的原理是从`ByteBuf`的可读字节中找到`\n`或者`\r\n`,找到之后就以此为结束,然后将当前读取到的数据组成一行.

如果我们设置每一行的最大长度, 但是当达到最大长度之后还没有找到结束符,就会抛出异常,同时将读取的数据舍弃掉.

`LineBasedFrameDecoder`的用法很简单, 我们可以向其指定大小或者不指定大小
```java
...
ch.pipline().addLast(new LineBasedFrameDecoder());
...
或者
...
ch.pipline().addLast(new LineBasedFrameDecoder(1024));
...
```

## DelimiterBasedFrameDecoder
使用`DelimiterBasedFrameDecoder`我们可以自定义设定分隔符
```java
...
ByteBuf delimiter = Unpooled.copiedBuffer("$_".getBytes());
ch.pipline().addLast(new DelimiterBasedFrameDecoder(1024, delimiter));
```
在上面的例子中我们使用了自定义的分隔符`$_`, 同样的如果在1024个字节中找不到`$_`, 也会抛出.

## FixedLengthFrameDecoder
`FixedLengthFrameDecoder`为定长解码器, 它会按照指定长度对消息进行解码.
```java
ch.pipline().addLast(new FixedLengthFrameDecoder(1024));
```
上面的例子会每隔1024个长度之后进行消息解码,如果不足1024,则会将消息缓存起来,然后再进行解码

## ProtobufVarint32FrameDecoder
`ProtoBufVarint32FrameDecoder`是Netty为我们提供的Protobuf半包解码器, 通过它配合使用`ProtobufDecoder`和`ProtobufEncoder`我们就可以使用Protobuf进行通信了
```java
ch.pipline().addLast(new ProtobufVarint32FrameDecoder());
ch.pipline().addLast(new ProtobufDecoder());
ch.pipline().addLast(new ProtobufEncoder());
```

## LengthFieldBasedFrameDecoder
`LengthFieldBasedFrameDecoder`是Netty为我们提供的通用半包解码器.

## ByteToMessageDecoder
如果我们自己想要实现自己的半包解码器,我们可以继承`ByteToMessageDecoder`, 实现更加复杂的半包解码

## HTTP解码器
* `HttpRequestDecoder` : Http消息解码器
* `HttpObjectAggregator` : 将多个消息转换为单一的`FullHttpRequest`或者`FullHttpResponse`
* `HttpResponseEncoder` : 对Http消息影响进行编码
* `ChunkedWriteHandler` : 异步大码流消息发送

> 使用`HttpObjectAggregator`是因为在解码Http消息中会产生多个对象(`HttpRequest`, `HttpResponse`, `HttpContent`, `LastHttpContent`), 使用`HttpObjectAggregator`我们可以将这些对象都组合到一起去. 然后当我们自己在处理消息时就可以直接使用`FullHttpRequest了`


```java
ch.pipline().addLast("http-decoder", new HttpRequestDecoder());
ch.pipline().addLast("http-aggregator", new HttpObjectAggregator());
ch.pipline().addLast("http-encoder", new HttpResponseEncoder());
ch.pipline().addLast("http-chunked", new ChunkedWriteHandler());
```