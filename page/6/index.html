
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>ming15</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="ming15">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="ming15">
<meta property="og:url" content="http://www.ming15.wang/page/6/index.html">
<meta property="og:site_name" content="ming15">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ming15">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="ming15" type="application/atom+xml">
    
    
    
    <link rel="apple-touch-icon" href="/img/author.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/author.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="ming15" title="ming15"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="ming15">ming15</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
						<form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 17728547076946147000 ><input type="text" name="q" size="30" placeholder="Search"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/24/mycat/mycat/" title="Mycat配置文件" itemprop="url">Mycat配置文件</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-23T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><a href="https://item.taobao.com/item.htm?spm=a230r.1.14.8.eRsdoe&amp;id=44263828402&amp;ns=1&amp;abbucket=17#detail" target="_blank" rel="external">Mycat权威指南V1</a>学习总结</p>
<blockquote>
<p>需要注意的一点是Mycat是支持分库,但是不支持分表的.</p>
</blockquote>
<ul>
<li>启动Mycat <code>mycat.bat start</code></li>
<li>连接Mycat <code>mysql -hlocalhost -P8066 -utest -ptest</code></li>
</ul>
<h2 id="schema-xml"><a href="#schema-xml" class="headerlink" title="schema.xml"></a>schema.xml</h2><p>下面的例子实现一个分库,db1和db2各有一张idTable表<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://org.opencloudb/"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"idDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"idTable"</span> <span class="attr">primaryKey</span>=<span class="string">"ID"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"mod-long"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"localhost1"</span> <span class="attr">database</span>=<span class="string">"db1"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn2"</span> <span class="attr">dataHost</span>=<span class="string">"localhost1"</span> <span class="attr">database</span>=<span class="string">"db2"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"localhost1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span> <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"localhost:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们要实现分库的功能需要在<code>rule.xml</code>中指定分库逻辑</p>
<h3 id="schema标签"><a href="#schema标签" class="headerlink" title="schema标签"></a>schema标签</h3><p>定义MyCat实例中的逻辑库,对于客户端来说,实际的数据库是不可见的,在sql中要使用逻辑库名称而不是实际的物理库的名称</p>
<ul>
<li><code>dataNode</code> : 对应实际的物理库(如果设置了这个属性,该逻辑库就不能实现分库功能了,但是该逻辑库就可以用作读写分离和主从切换). 它的值对应下面的dataNode标签.</li>
<li><code>checkSQLschema</code> : 把schema字符去掉(在sql中将库名去掉)</li>
<li><code>sqlMaxLimit</code> : 在分库中执行sql时,为sql添加<code>limit</code>字段</li>
<li><code>name</code> : 逻辑库名称</li>
</ul>
<h4 id="table标签"><a href="#table标签" class="headerlink" title="table标签"></a>table标签</h4><p>定义MyCat中的逻辑表</p>
<ul>
<li><code>name</code> : 逻辑表表名</li>
<li><code>dataNode</code> : 定义逻辑表所属的dataNode, 该属性值与schema标签dataNode属性值相对应</li>
<li><code>rule</code> : 指定逻辑表要使用定义在rule.xml中的规则名字</li>
<li><code>ruleRequired</code> : 指定表是否绑定分片规则(如果指定绑定但是在rule.xml中找不到则会报错)</li>
<li><code>primaryKey</code> : 逻辑表对应真实表的主键</li>
<li><code>type</code> : 逻辑表类型(可选值为global表示全局表,不设置的话为非全局表). 全局表就是每个分片内都保存一份全完相同的数据.</li>
<li><code>autoIncrement</code> : 自增长主键,但是需要在Mysql中设置auto_increment属性</li>
<li><code>needAddLimit</code> : 如果为false, 会屏蔽sqlMaxLimit功能</li>
</ul>
<h5 id="childTable标签"><a href="#childTable标签" class="headerlink" title="childTable标签"></a>childTable标签</h5><p>用于定义E-R分片的子表</p>
<ul>
<li><code>name</code> : 子表名</li>
<li><code>joinKey</code> : 插入子表的时候会使用这个列的值查找父表存储的数据节点</li>
<li><code>parentKey</code> : </li>
<li><code>primaryKey</code> : 逻辑表对应真实表的主键</li>
<li><code>needAddLimit</code> : 如果为false, 会屏蔽sqlMaxLimit功能</li>
</ul>
<h3 id="dataNode标签"><a href="#dataNode标签" class="headerlink" title="dataNode标签"></a>dataNode标签</h3><p>定义MyCat中的数据节点(也就是数据分片). </p>
<ul>
<li><code>name</code> : 数据节点名字</li>
<li><code>dataHost</code> : 定义该分片属于哪个数据库实例</li>
<li><code>database</code> : 分片属性哪个具体数据库实例上的具体库</li>
</ul>
<h3 id="dataHost标签"><a href="#dataHost标签" class="headerlink" title="dataHost标签"></a>dataHost标签</h3><p>定义了具体的数据库实例、读写分离配置和心跳语句。</p>
<ul>
<li><code>name</code> : dataHost标签名</li>
<li><code>maxCon</code> : 每个读写实例连接池的最大连接</li>
<li><code>minCon</code> : 每个读写实例连接池的最小连接，初始化连接池的大小。</li>
<li><code>balance</code> : 负载均衡类型(<code>0</code>:所有读操作都发送到当前可用的writeHost上。’1<code>:所有读操作都随机的发送到readHost。</code>2`:所有读操作都随机的在writeHost、readhost上分发。)</li>
<li><code>writeType</code> : 同balance属性</li>
<li><code>dbType</code> : 后端连接的数据库类型(mysql,oracle等等)</li>
<li><code>dbDriver</code> : 连接后端数据库使用的Driver，目前可选的值有native和JDBC</li>
</ul>
<h4 id="heartbeat标签"><a href="#heartbeat标签" class="headerlink" title="heartbeat标签"></a>heartbeat标签</h4><p>用于和后端数据库进行心跳检查的语句 </p>
<h4 id="writeHost-readHost"><a href="#writeHost-readHost" class="headerlink" title="writeHost, readHost"></a>writeHost, readHost</h4><p>用于实例化后端连接池.在一个dataHost内可以定义多个writeHost和readHost。但是，如果writeHost指定的后端数据库宕机，那么这个writeHost绑定的所有readHost都将不可用。另一方面，由于这个writeHost宕机系统会自动的检测到，并切换到备用的writeHost上去。</p>
<ul>
<li><code>host</code> : 标识不同实例</li>
<li><code>url</code> : 后端实例连接地址</li>
<li><code>password</code> : </li>
<li><code>user</code> : 后端存储实例需要的用户名字</li>
<li><code>password</code> :  后端存储实例需要的密码</li>
</ul>
<h2 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h2><p>保存mycat需要的系统配置信息.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:server</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://org.opencloudb/"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">system</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultSqlParser"</span>&gt;</span>druidparser<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>idDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:server</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="user标签"><a href="#user标签" class="headerlink" title="user标签"></a>user标签</h3><p>定义登录mycat的用户和权限,它可以定义<code>property</code>子标签.<code>property</code>子标签的name值可以是：</p>
<ul>
<li><code>password</code> : 该用户的密码</li>
<li><code>schemas</code> : 该用户可访问的schema(在schema.xml中定义的schema)</li>
<li><code>readOnly</code> : 该用户的读写权限</li>
</ul>
<h3 id="system标签"><a href="#system标签" class="headerlink" title="system标签"></a>system标签</h3><p>与系统配置有关.它同样使用<code>property</code>子标签.<code>property</code>子标签的name值可以是：</p>
<ul>
<li><code>defaultSqlParser</code> : 指定默认的解析器</li>
<li><code>processors</code> : 指定系统可用的线程数.(主要影响processorBufferPool、processorBufferLocalPercent、processorExecutor属性)</li>
<li><code>processorBufferChunk</code> : 这个属性指定每次分配Socket Direct Buffer的大小，默认是4096个字节。这个属性也影响buffer pool的长度。</li>
<li><code>processorBufferPool</code> : 这个属性指定bufferPool计算 比例值.</li>
<li><code>processorBufferLocalPercent</code> : 控制分配ThreadLocalPool的大小用的，但其也并不是一个准确的值，也是一个比例值。这个属性默认值为100。</li>
<li><code>processorExecutor</code> : 指定NIOProcessor上共享的businessExecutor固定线程池大小</li>
<li><code>sequnceHandlerType</code> : 指定使用Mycat全局序列的类型。0为本地文件方式，1为数据库方式。</li>
</ul>
<h4 id="TCP连接相关属性"><a href="#TCP连接相关属性" class="headerlink" title="TCP连接相关属性"></a>TCP连接相关属性</h4><ul>
<li><code>frontSocketSoRcvbuf</code> : </li>
<li><code>frontSocketSoSndbuf</code> : </li>
<li><code>frontSocketNoDelay</code> : </li>
</ul>
<h4 id="Mysql连接相关属性"><a href="#Mysql连接相关属性" class="headerlink" title="Mysql连接相关属性"></a>Mysql连接相关属性</h4><ul>
<li><code>packetHeaderSize</code> : 指定Mysql协议中的报文头长度</li>
<li><code>maxPacketSize</code> : 指定Mysql协议可以携带的数据最大长度</li>
<li><code>idleTimeout</code> :  指定连接的空闲超时时间。某连接在发起空闲检查下，发现距离上次使用超过了空闲时间，那么这个连接会被回收，就是被直接的关闭掉。默认30分钟。</li>
<li><code>charset</code> : 连接的初始化字符集。默认为utf8。</li>
<li><code>txIsolation</code> : 前端连接的初始化事务隔离级别，只在初始化的时候使用，后续会根据客户端传递过来的属性对后端数据库连接进行同步。默认为REPEATED_READ。</li>
<li><code>sqlExecuteTimeout</code> : SQL执行超时的时间，Mycat会检查连接上最后一次执行SQL的时间，若超过这个时间则会直接关闭这连接。默认时间为300秒。</li>
</ul>
<h4 id="周期间隔相关属性"><a href="#周期间隔相关属性" class="headerlink" title="周期间隔相关属性"></a>周期间隔相关属性</h4><ul>
<li><code>processorCheckPeriod</code> : </li>
<li><code>dataNodeIdleCheckPeriod</code> : </li>
<li><code>dataNodeHeartbeatPeriod</code> :</li>
</ul>
<h4 id="服务相关属性"><a href="#服务相关属性" class="headerlink" title="服务相关属性"></a>服务相关属性</h4><ul>
<li><code>bindIp</code> :  mycat服务监听的IP地址，默认值为0.0.0.0。</li>
<li><code>serverPort</code> : mycat的使用端口，默认值为8066。</li>
<li><code>managerPort</code> : mycat的管理端口，默认值为9066。</li>
</ul>
<h2 id="rule-xml"><a href="#rule-xml" class="headerlink" title="rule.xml"></a>rule.xml</h2><p>对表进行拆分所涉及到的规则定义<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"rule2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">columns</span>&gt;</span>user_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>func1<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="tableRule标签"><a href="#tableRule标签" class="headerlink" title="tableRule标签"></a>tableRule标签</h3><p>定义表规则</p>
<ul>
<li><code>name</code> : 表规则名称</li>
</ul>
<h4 id="rule标签"><a href="#rule标签" class="headerlink" title="rule标签"></a>rule标签</h4><p>指定对物理表中的哪一列进行拆分和使用什么路由算法。</p>
<h5 id="columns标签"><a href="#columns标签" class="headerlink" title="columns标签"></a>columns标签</h5><p>指定要拆分的列名字。</p>
<h5 id="algorithm标签"><a href="#algorithm标签" class="headerlink" title="algorithm标签"></a>algorithm标签</h5><p>使用function标签中的name属性。</p>
<h3 id="function标签"><a href="#function标签" class="headerlink" title="function标签"></a>function标签</h3><ul>
<li><code>name</code> : 算法的名字</li>
<li><code>class</code> : 制定路由算法具体的类名字</li>
</ul>
<h4 id="property标签"><a href="#property标签" class="headerlink" title="property标签"></a>property标签</h4><p>具体算法需要用到的一些属性</p>
<ul>
<li><code>name</code> : </li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/mycat/">mycat</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/24/mycat/mycat/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/24/mycat/mycat/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/24/jvm/instrument 初探/" title="instrument 初探" itemprop="url">instrument 初探</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-23T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>使用 Instrumentation，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义。</p>
<p>Instrumentation提供了这样的功能：</p>
<ul>
<li>获取某个对象的大小</li>
<li>热加载class文件</li>
<li>获取JVM信息</li>
</ul>
<blockquote>
<p>要知道一个对象所使用的内存量,需要将所有实例变量使用的内存和对象本身的开销(一般是16字节)相加.这些开销包括一个指向对象的类的引用,垃圾收集信息和同步信息.另外一般内存的使用会被填充为8字节的倍数.</p>
</blockquote>
<h2 id="Premain"><a href="#Premain" class="headerlink" title="Premain"></a>Premain</h2><p>premain函数是JavaSE5中实现instrument的方式.</p>
<p>使用premain我们要自定义MANIFEST.MF文件, 定义Premain-Class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Premain-Class: wang.ming15.instrument.core.Premain</span><br></pre></td></tr></table></figure></p>
<p>然后我们在maven文件中输出该文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifestFile</span>&gt;</span></span><br><span class="line">                        src/main/resources/META-INF/MANIFEST.MF</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifestFile</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="获取对象大小"><a href="#获取对象大小" class="headerlink" title="获取对象大小"></a>获取对象大小</h3><p>首先我们要写一个代理文件出来(该文件放在<code>core-1.0-SNAPSHOT.jar</code>中)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Premain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Instrumentation instrumentation;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">		instrumentation = inst;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instrumentation;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在自己的应用程序中引用该文件(在<code>examples-1.0-SNAPSHOT.jar</code>中)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintObjectSize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello world, App"</span>);</span><br><span class="line"></span><br><span class="line">		objectSize();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">objectSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Instrumentation inst = Premain.getInstrumentation();</span><br><span class="line">		String str = <span class="string">"123456789"</span>;</span><br><span class="line">		<span class="keyword">long</span> size = inst.getObjectSize(str);</span><br><span class="line">		System.out.println(str + <span class="string">" 对象大小: "</span> + size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后执行命令<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:../instrument/target/core-<span class="number">1.0</span>-SNAPSHOT.jar -cp ./target/examples-<span class="number">1.0</span>-SNAPSHOT.jar wang.ming15.instrument.examples.PrintObjectSize</span><br></pre></td></tr></table></figure></p>
<p>然后就会获得对象的大小<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello world, App</span><br><span class="line"><span class="number">123456789</span> 对象大小: <span class="number">24</span></span><br></pre></td></tr></table></figure></p>
<h3 id="加载jar包"><a href="#加载jar包" class="headerlink" title="加载jar包"></a>加载jar包</h3><p>我们在Premain类中增加一个加载jar的功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendJarToSystemClassLoader</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">	JarFile jarFile = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		jarFile = <span class="keyword">new</span> JarFile(path);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	instrumentation.appendToSystemClassLoaderSearch(jarFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendJarToBootstrapClassLoader</span><span class="params">(Instrumentation inst, String path)</span> </span>&#123;</span><br><span class="line">	JarFile jarFile = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		jarFile = <span class="keyword">new</span> JarFile(path);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	inst.appendToBootstrapClassLoaderSearch(jarFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们写一个测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJarLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">120</span>; i++) &#123;</span><br><span class="line">			Premain.appendJarToSystemClassLoader(args[<span class="number">0</span>]);</span><br><span class="line">			Print.print();</span><br><span class="line"></span><br><span class="line">			Stream.of(Premain.getInstrumentation().getAllLoadedClasses())</span><br><span class="line">					.filter(clazz -&gt; clazz.getName().contains(<span class="string">"Print"</span>))</span><br><span class="line">					.forEach(aClass -&gt; System.out.println(aClass.getName() + <span class="string">"  "</span> + aClass.getMethods().length));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后执行命令<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:../instrument/target/core-<span class="number">1.0</span>-SNAPSHOT.jar -cp ./target/examples-<span class="number">1.0</span>-SNAPSHOT.jar wang.ming15.instrument.examples.TestJarLoader D:/workspace/idea/instrument/trunk/print/target/print-<span class="number">1.0</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></p>
<p>结果输出为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Now Time is Thu Dec <span class="number">31</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">39</span> CST <span class="number">2015</span></span><br><span class="line"></span><br><span class="line">wang.ming15.instrument.print.Print  <span class="number">11</span></span><br><span class="line">java.io.PrintStream  <span class="number">44</span></span><br><span class="line">Now Time is Thu Dec <span class="number">31</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">44</span> CST <span class="number">2015</span></span><br><span class="line"></span><br><span class="line">wang.ming15.instrument.print.Print  <span class="number">11</span></span><br><span class="line">java.io.PrintStream  <span class="number">44</span></span><br></pre></td></tr></table></figure></p>
<h3 id="重新加载类"><a href="#重新加载类" class="headerlink" title="重新加载类"></a>重新加载类</h3><p>我们使用<code>redefineClasses()</code>可以使用提供的字节码重新定义Class. 这个方法会使用新的字节码全部替换原先存在的Class字节码. 而如果想要修改原先存在的Class字节码应该使用<code>retransformClasses()</code>方法.</p>
<p>对于已经在栈帧中的字节码, 他们会继续执行下去, 但是当方法再次调用的时候,则会使用刚刚加载完成的新的字节码.</p>
<p>同时需要注意的是<code>redefineClasses()</code>并不会触发初始化操作, 也不会抛出初始化时的异常. 因此一些静态属性并不会被重新赋值</p>
<p>在重新加载类的时候, 该类已经实例化出的对象同时也不会受到影响.</p>
<p>该方法的操作过程是一个基于操作集合的, 也就是说在redefine的时候, 可能有A B俩个类都进行, 而且A依赖于B, 那么在redefine的时候这俩个操作是同时完成的, 类似于原子操作.</p>
<p>还需要指明的是, redefine 操作虽然可以改变方法体, 常量池以及属性, 但是redefine过程肯定不能对属性或者方法进行增加,删除,重命名的操作, 也不能修改方法签名以及修改继承关系.</p>
<p>在redefine过程中,一旦抛出异常, 那么此过程执已经redefine成功的class也会被会滚成原来的.</p>
<p>想使用这个功能我们需要在MANIFEST.MF文件中增加这样一行<code>Can-Redefine-Classes: true</code>, 然后我们在Premain中增加一个redefine方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">redefineClasses</span><span class="params">(Class clazz, String path)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!instrumentation.isRedefineClassesSupported()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//		InputStream input = Premain.class.getClassLoader().getResourceAsStream(path);</span></span><br><span class="line">		InputStream input = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[input.available()];</span><br><span class="line">		input.read(bytes);</span><br><span class="line">		instrumentation.redefineClasses(<span class="keyword">new</span> ClassDefinition(clazz, bytes));</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (UnmodifiableClassException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们写一个测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			Test.print();</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">			Premain.redefineClasses(Test.class, <span class="string">"D://Test.class"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后成功输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I am a big T</span><br><span class="line">I am a big T</span><br><span class="line">I am a big T</span><br><span class="line">I am a big T</span><br><span class="line">I am a big T</span><br><span class="line">I am a big T</span><br><span class="line">I am a big T</span><br><span class="line">I am a big T ok</span><br><span class="line">I am a big T ok</span><br></pre></td></tr></table></figure></p>
<h2 id="Agentmain"><a href="#Agentmain" class="headerlink" title="Agentmain"></a>Agentmain</h2><p>在 Java SE 5 中premain 所作的 Instrumentation 也仅限与 main 函数执行前，这样的方式存在一定的局限性。Java SE 6 针对这种状况做出了改进，开发者可以在 main 函数开始执行以后，再启动自己的 Instrumentation 程序。在 Java SE 6 的 Instrumentation 当中，有一个跟 premain“并驾齐驱”的“agentmain”方法，可以在 main 函数开始运行之后再运行。</p>
<p>首先我们还是需要修改MANIFEST.MF文件, 在其中添加<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Agent-Class: wang.ming15.instrument.core.Agentmain</span><br></pre></td></tr></table></figure></p>
<h2 id="获取对象大小-1"><a href="#获取对象大小-1" class="headerlink" title="获取对象大小"></a>获取对象大小</h2><p>同样我们还是先输出一下对象的大小<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JVM/">JVM</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/24/jvm/instrument 初探/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/24/jvm/instrument 初探/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/23/JavaSE/JavaIO NIO/" title="JDK4 NIO" itemprop="url">JDK4 NIO</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-22T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>JDK1.4 引入的NIO(Non-block IO)是为了拟补原来阻塞IO的不足,它提供了高速的,面向块的IO. </p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>在JDK1.4的NIO中所有的数据都是通过缓冲区(Buffer)处理的. 缓冲区本质上就是一个字节数组, 但是JDK还提供了其他种类的缓冲区：</p>
<ul>
<li>ByteBuffer </li>
<li>ByteOrder </li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer         </li>
<li>IntBuffer          </li>
<li>LongBuffer         </li>
<li>MappedByteBuffer   </li>
<li>ShortBuffer  </li>
</ul>
<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>在JDK1.4的NIO中还引入了如下的Channel     </p>
<ul>
<li>DatagramChannel : 数据报相关的Channel</li>
<li>FileChannel : 文件Channel</li>
<li>ServerSocketChannel  : 用于接受入站连接的SocketChannel(不可进行读写)</li>
<li>SocketChannel  : 用于读写数据的Channel</li>
</ul>
<h2 id="NIO服务器"><a href="#NIO服务器" class="headerlink" title="NIO服务器"></a>NIO服务器</h2><p>使用ServerSocketChannel可以像使用<code>ServerSocket</code>一样开发网络服务器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ServerSocketChannel,监听所有客户端连接</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定监听端口</span></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8085</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	SocketChannel ssc = serverSocketChannel.accept();</span><br><span class="line">	<span class="keyword">if</span> (ssc == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ssc.read(byteBuffer);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(byteBuffer.array(), <span class="string">"utf8"</span>));</span><br><span class="line">		ssc.write(byteBuffer);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Select版本<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ServerSocketChannel,监听所有客户端连接</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定监听端口</span></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8085</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多路复用器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将ServerSocketChannel注册到多路复用器上, 监听accept事件. 然后Selector会不断的轮询(基于系统的select/poll)</span></span><br><span class="line"><span class="comment">// SocketChannel是否有新的连接到达达到，selectedKeys()方法就会将准备就绪的连接作为一个集合返回.</span></span><br><span class="line"><span class="comment">// 在这里我们只能注册accept事件,其他的读写事件我们要在</span></span><br><span class="line"><span class="comment">// accept之后获得的SocketChannel上注册Selector,进行读写事件注册. 也就是说我们不能在ServerSocketChannel上进行读写,</span></span><br><span class="line"><span class="comment">// 我们只能在SocketChannel上进行读写</span></span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	<span class="comment">// 进行多路复用,这里对Selector进行复用,复用是对一个ServerSocketChannel和多个SocketChannel进行复用.</span></span><br><span class="line">	selector.select();</span><br><span class="line">	selector.selectedKeys().forEach(selectionKey -&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span> (selectionKey.isConnectable()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"isConnectable"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">			<span class="comment">// 由于在Selector上是对ServerSocketChannel进行的accept事件监听,因此此处,我们需要将Channel转换成ServerSocketChannel</span></span><br><span class="line">			ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				SocketChannel socketChannel = ssc.accept();</span><br><span class="line">				socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">				<span class="comment">// 此处我们将accept的SocketChannel注册到Selector上, 进行读写处理</span></span><br><span class="line">				socketChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">			<span class="comment">// selectionKey.isAcceptable()这个判断中我们将SocketChannel注册到Selector上接受读事件,</span></span><br><span class="line">			<span class="comment">// 因此我们在此处需要将Channel转换成SocketChannel</span></span><br><span class="line">			SocketChannel ssc = (SocketChannel) selectionKey.channel();</span><br><span class="line">			ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				ssc.read(byteBuffer);</span><br><span class="line">				System.out.println(<span class="keyword">new</span> String(byteBuffer.array(), <span class="string">"utf8"</span>));</span><br><span class="line">				ssc.write(byteBuffer);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"isWritable"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (selectionKey.isValid()) &#123;</span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			System.out.println(<span class="string">"isValid"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看一下<code>Selector</code></p>
<p><code>`是</code>SelectableChannel`的多路复用器. </p>
<p>我们可以通过调用<code>Selector#open()</code>方法来创建一个selector. 当这个selector创建出来之后, 当我们调用<code>Selector#close()</code>方法之前, 该selector会一直存在.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/23/JavaSE/JavaIO NIO/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/23/JavaSE/JavaIO NIO/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/23/netty/Channel/" title="Netty Channel" itemprop="url">Netty Channel</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-22T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><code>Channel</code>是Netty网络抽象类. 它的功能包括网络IO的读写,链路的连接和关闭, 通信双方的通信地址等.<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/netty/channel.jpg" alt=""></p>
<p>下面我们看一下Channel提供的API</p>
<ul>
<li><code>parent()</code> : 获取父Channel</li>
<li><code>unsafe()</code> :</li>
<li><code>localAddress()</code> : 当前Channel的本地绑定地址</li>
<li><code>eventLoop()</code> : 当前Channel注册到的EventLoop对象</li>
<li><code>config()</code> : 获取当前Channel的配置信息</li>
<li><code>remoteAddress()</code> : 当前Channel通信的远程Socket地址</li>
<li><code>metadata()</code> : 当前Channel的元数据描述信息,例如TCP参数等等</li>
<li><code>isOpen()</code> : 判断当初Channel是否已经打开</li>
<li><code>isWritable()</code> : 当前Channel是否可写</li>
<li><code>isRegistered()</code> : 是否注册当EventLoop上</li>
<li><code>isActive()</code> : 当前Channel是否处于激活状态</li>
<li><code>pipeline()</code> : 当前Channel的ChannelPipeline对象</li>
</ul>
<p>下面的网络IO操作会直接调用ChannelPipeline里的方法, 在ChannelPipeline里进行事件传播</p>
<ul>
<li><code>read()</code> : 从Channel中读取数据到inbound缓冲区</li>
<li><code>write()</code> : 将消息通过ChannelPipeline写入到目标Channel中</li>
<li><code>close()</code> : 主动关闭与网络对端的连接</li>
<li><code>flush()</code> : 将之前写到环形队列里的消息全部写到目标Channel中,发送给网络对端</li>
<li><code>connect()</code> : 与网络对端发起连接请求(一般由客户端调用这个方法)</li>
<li><code>bind()</code> :</li>
<li><code>disconnect()</code> : 请求关闭与网络对端的连接.</li>
</ul>
<h2 id="AbstractChannel"><a href="#AbstractChannel" class="headerlink" title="AbstractChannel"></a>AbstractChannel</h2><p>我们首先看一下<code>AbstractChannel</code>里定义的成员<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链路已经关闭异常</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException CLOSED_CHANNEL_EXCEPTION = <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line"><span class="comment">// 链路尚未连接异常</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> NotYetConnectedException NOT_YET_CONNECTED_EXCEPTION = <span class="keyword">new</span> NotYetConnectedException();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    CLOSED_CHANNEL_EXCEPTION.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);</span><br><span class="line">    NOT_YET_CONNECTED_EXCEPTION.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于预测下一个报文的大小.</span></span><br><span class="line"><span class="keyword">private</span> MessageSizeEstimator.Handle estimatorHandle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Channel parent;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelPipeline pipeline;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelFuture succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> VoidChannelPromise voidPromise = <span class="keyword">new</span> VoidChannelPromise(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> VoidChannelPromise unsafeVoidPromise = <span class="keyword">new</span> VoidChannelPromise(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CloseFuture closeFuture = <span class="keyword">new</span> CloseFuture(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地IP地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> SocketAddress localAddress;</span><br><span class="line"><span class="comment">// 网络通信对端的IP地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> SocketAddress remoteAddress;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> EventLoop eventLoop;</span><br><span class="line"><span class="comment">// Channel是否注册到了EventLoop上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> registered;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache for the string representation of this channel */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> strValActive;</span><br><span class="line"><span class="keyword">private</span> String strVal;</span><br></pre></td></tr></table></figure></p>
<p><code>AbstractChannel</code>聚合了所有Channel使用到的能力的对象. 如果某个功能和子类相关则定义抽象方法,由子类去实现.</p>
<p>在这里我们主要关注三个变量</p>
<ul>
<li><code>unsafe</code> : 真实网络IO的操作类</li>
<li><code>pipeline</code> : 当前Channel对应的ChannelPipeline. 负责</li>
<li><code>eventLoop</code> : 该Channel注册到的EventLoop<br>在实例化的时候, 会对<code>pipeline</code>和<code>unsafe</code>进行赋值.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.parent = parent;</span><br><span class="line">      unsafe = newUnsafe();</span><br><span class="line">      pipeline = <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>unsafe实例化由子类实现, 这是因为unsafe的类型是个Unsafe接口, 而且AbstractChannel的内部类AbstractUnsafe是个抽象类, 那么我们就不知道如果要实例化这个类型究竟要使用哪个类型, 因此让AbstractChannel的子类继续实现自己的Unsafe接口的内部类和newUnsafe()方法, unsafe实质类型就有很大的可扩展性</p>
</blockquote>
<p>我们看到每一个Channel都有一个自己的<code>pipeline</code>和<code>unsafe</code>. <code>eventLoop</code>是在<code>AbstractUnsafe</code>中<code>register()</code>方法调用时进行赋值的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>AbstractChannel</code>完成的功能很少, 只是实现了一些初始化的工作, 然后将网络相关的建立,数据读写操作等交给<code>pipeline</code>来完成.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">disconnect</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.disconnect(promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">close</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.close(promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Override</span><br><span class="line"><span class="keyword">public</span> Channel <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipeline.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.write(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还提供了一个<code>unsafe()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Unsafe <span class="title">unsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> unsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看一下<code>AbstractUnsafe</code>的定义<code>protected abstract class AbstractUnsafe implements Unsafe</code>, 它是作为一个<code>AbstractChannel</code>的抽象内部类, 这种关系也很容易让<code>AbstractUnsafe</code>访问<code>AbstractChannel</code>定义的一些空实现方法. 例如<code>AbstractUnsafe</code>中调用<code>AbstractChannel</code>的方法如下</p>
<ul>
<li><code>beginRead()</code> -&gt; <code>doBeginRead()</code></li>
<li><code>doBind()</code> -&gt; <code>doBind()</code></li>
<li><code>doDisconnect()</code> -&gt; <code>doDisconnect()()</code></li>
<li><code>doClose()</code> -&gt; <code>doClose()</code></li>
<li><code>register()</code> -&gt; <code>doRegister()</code>以及调用pipeline的相关方法(fireChannelRegistered()和fireChannelActive())</li>
</ul>
<h2 id="AbstractNioChannel"><a href="#AbstractNioChannel" class="headerlink" title="AbstractNioChannel"></a>AbstractNioChannel</h2><p><code>AbstractNioChannel</code>主要是实现了<code>AbstractChannel</code>的<code>doRegister(), doDeregister(), doBeginRead()</code>方法. 通过下面的变量我们也可以看出这个类主要是为了完成<code>SelectableChannel</code>向<code>Selector</code>的注册功能.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectableChannel ch;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> readInterestOp;</span><br><span class="line"><span class="keyword">volatile</span> SelectionKey selectionKey;</span><br></pre></td></tr></table></figure></p>
<p><code>java.nio.channels.ServerSocketChannel</code>和<code>java.nio.channels.SocketChannel</code>都是实现了<code>java.nio.channels.SelectableChannel</code>接口. 而<code>NioSocketChannel</code>和<code>NioServerSocketChannel</code>实现了<code>AbstractNioChannel</code>接口, 因此我们在<code>AbstractNioChannel</code>内定义了一个<code>SelectableChannel</code>成员用于实现<code>ServerSocketChannel</code>和<code>SocketChannel</code>的共用</p>
<p>然后我们看一下<code>doRegister()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 我们将ServerSocketChannel或者SocketChannel注册到NioEventLoop里的Selector上</span></span><br><span class="line">			<span class="comment">// 0表示我们对任何事件Channel里的任何事件都不感兴趣</span></span><br><span class="line">			<span class="comment">// 同时我们将this作为附件传送进去,</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().selector, <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                <span class="comment">// Force the Selector to select now as the "canceled" SelectionKey may still be</span></span><br><span class="line">                <span class="comment">// cached and not removed because no Select.select(..) operation was called yet.</span></span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></span><br><span class="line">                <span class="comment">// for whatever reason. JDK bug ?</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后我们看一下<code>doBeginRead()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">if</span> (inputShutdown) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取selectionKey的操作位</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果slectionKey不对读事件感兴趣, 那么就修改selectionKey的操作位, 开始设置对读事件感兴趣</span></span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还记得在<code>AbstractChannel</code>中的<code>AbstractUnsafe</code>吗?里面有个<code>beginRead()</code>, 这个<code>doBeginRead()</code>正是由其调用的.</p>
<h2 id="AbstractNioByteChannel"><a href="#AbstractNioByteChannel" class="headerlink" title="AbstractNioByteChannel"></a>AbstractNioByteChannel</h2><p><code>AbstractNioByteChannel</code>内部只有一个<code>Runnable</code>类型的<code>flushTask</code>属性, 它是用来写半包的, 当我们使用到它的时候,我们再具体分析. 我们来重点看一下<code>doWrite()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> writeSpinCount = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">// 从环形数组ChannelOutboundBuffer中弹出一个消息对象</span></span><br><span class="line">           Object msg = in.current();</span><br><span class="line">           <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 如果全部消息都发送完毕累,则清除半包标志, clearOpWrite() 内部操作 TODO ???</span></span><br><span class="line">               clearOpWrite();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">               ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">               <span class="keyword">int</span> readableBytes = buf.readableBytes();</span><br><span class="line">               <span class="keyword">if</span> (readableBytes == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// 当前消息没有可读内容, 也就是没有内容需要向外发送,</span></span><br><span class="line">                   <span class="comment">// 则将其从还行数组中删除, 然后继续处理下一个消息</span></span><br><span class="line">                   in.remove();</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//设置半包标志</span></span><br><span class="line">               <span class="keyword">boolean</span> setOpWrite = <span class="keyword">false</span>;</span><br><span class="line">               <span class="comment">// 设置消息是否发送完毕</span></span><br><span class="line">               <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">               <span class="comment">// 设置消息发送的总得数量</span></span><br><span class="line">               <span class="keyword">long</span> flushedAmount = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span> (writeSpinCount == -<span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="comment">// 从配置中我们获取每次写半包消息进行的最大次数. 也即是如果环形数组里的消息一次性发送</span></span><br><span class="line">                   <span class="comment">// 不完, 需要循环发送的次数,至于为什么不一直发送, 这是因为如果网络阻塞或者对方接受数据很慢,可能会造成网络IO线程假死</span></span><br><span class="line">                   writeSpinCount = config().getWriteSpinCount();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = writeSpinCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">                   <span class="comment">// 将buf内部的数据进行发送, 返回值是数据发送量</span></span><br><span class="line">                   <span class="keyword">int</span> localFlushedAmount = doWriteBytes(buf);</span><br><span class="line">                   <span class="keyword">if</span> (localFlushedAmount == <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="comment">// 数量为0,说明一个数据都没有发送出去, 可能是TCP缓冲区满了. 因此设置写半包标志</span></span><br><span class="line">                       <span class="comment">// 同时退出写循环,这是因为下次写数据还可能TCP缓冲区处于已满状态,导致IO线程空循环</span></span><br><span class="line">                       setOpWrite = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 数据发送成功, 将发送的数据量累加到flushedAmount上.</span></span><br><span class="line">                   flushedAmount += localFlushedAmount;</span><br><span class="line">                   <span class="keyword">if</span> (!buf.isReadable()) &#123;</span><br><span class="line">                       <span class="comment">// 当前消息里的数据已经发送完毕, 退出buf发送循环,继续处理环形队列中下一个消息</span></span><br><span class="line">                       done = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 将发送的数据量同步到环形队列中</span></span><br><span class="line">               in.progress(flushedAmount);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                   <span class="comment">// buf数据已经发送完, 则将该消息从环形队列中删除</span></span><br><span class="line">                   in.remove();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 在写半包消息最大循环次数之内都没有将buf数据写完, 可能是数据量太多或者TCP缓冲区已满</span></span><br><span class="line">                   <span class="comment">// 释放当前IO线程,让其进行其他工作.</span></span><br><span class="line">                   incompleteWrite(setOpWrite);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FileRegion) &#123;</span><br><span class="line">               FileRegion region = (FileRegion) msg;</span><br><span class="line">               <span class="keyword">boolean</span> done = region.transfered() &gt;= region.count();</span><br><span class="line">               <span class="keyword">boolean</span> setOpWrite = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">                   <span class="keyword">long</span> flushedAmount = <span class="number">0</span>;</span><br><span class="line">                   <span class="keyword">if</span> (writeSpinCount == -<span class="number">1</span>) &#123;</span><br><span class="line">                       writeSpinCount = config().getWriteSpinCount();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> i = writeSpinCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                       <span class="keyword">long</span> localFlushedAmount = doWriteFileRegion(region);</span><br><span class="line">                       <span class="keyword">if</span> (localFlushedAmount == <span class="number">0</span>) &#123;</span><br><span class="line">                           setOpWrite = <span class="keyword">true</span>;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       flushedAmount += localFlushedAmount;</span><br><span class="line">                       <span class="keyword">if</span> (region.transfered() &gt;= region.count()) &#123;</span><br><span class="line">                           done = <span class="keyword">true</span>;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   in.progress(flushedAmount);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                   in.remove();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   incompleteWrite(setOpWrite);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Should not reach here.</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>doWrite()</code>方法是由<code>AbstractUnsafe</code>的<code>flush()</code>调用的. 从<code>AbstractUnsafe</code>我们可以看到每个Unsafe类都有一个<code>ChannelOutboundBuffer</code>属性.</p>
<p>下来我们看一下<code>incompleteWrite()</code>方法实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">incompleteWrite</span><span class="params">(<span class="keyword">boolean</span> setOpWrite)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从doWrite()方法中可以看到只有当TCP缓冲区已满的时候才会设置写半包操作</span></span><br><span class="line">        <span class="keyword">if</span> (setOpWrite) &#123;</span><br><span class="line">            <span class="comment">// 设置累写半包的话,则将SelectionKey注册为OP_WRITE, 让多路复用器不断的轮训对应的Channel,</span></span><br><span class="line">            <span class="comment">// 继续处理没有发送完的消息</span></span><br><span class="line">            setOpWrite();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有半包,则让eventLoop继续执行写半包操作</span></span><br><span class="line">            Runnable flushTask = <span class="keyword">this</span>.flushTask;</span><br><span class="line">            <span class="keyword">if</span> (flushTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">                flushTask = <span class="keyword">this</span>.flushTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        flush();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            eventLoop().execute(flushTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="AbstractNioMessageChannel"><a href="#AbstractNioMessageChannel" class="headerlink" title="AbstractNioMessageChannel"></a>AbstractNioMessageChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> SelectionKey key = selectionKey();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">// 从环形队列中获取一条消息</span></span><br><span class="line">           Object msg = in.current();</span><br><span class="line">           <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 消息为空,说明所有的消息都已经发送出去了. TODO</span></span><br><span class="line">               <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">                   key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = config().getWriteSpinCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                   <span class="comment">// 在配置的最大次数下,将msg发送出去</span></span><br><span class="line">                   <span class="keyword">if</span> (doWriteMessage(msg, in)) &#123;</span><br><span class="line">                       done = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                   <span class="comment">// 如果消息发送完毕累, 则将其从环形数组中删除</span></span><br><span class="line">                   in.remove();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//  如果没有发送完毕, 则设置SelectionKey为写操作位, 让多路复用器不断的轮训channel,发送剩余的数据</span></span><br><span class="line">                   <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="number">0</span>) &#123;</span><br><span class="line">                       key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               <span class="keyword">if</span> (continueOnWriteError()) &#123;</span><br><span class="line">                   in.remove(e);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">throw</span> e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="NioServerSocketChannel"><a href="#NioServerSocketChannel" class="headerlink" title="NioServerSocketChannel"></a>NioServerSocketChannel</h2><p><code>NioServerSocketChannel</code>的主要作用是接受客户端连接<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       SocketChannel ch = javaChannel().accept();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">               buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, t);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ch.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">               logger.warn(<span class="string">"Failed to close a socket."</span>, t2);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法调用主要是由<code>NioMessageUnsafe</code>的<code>read()</code>方法调用</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Netty/">Netty</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/23/netty/Channel/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/23/netty/Channel/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/21/JavaSE/JavaIO 写文件/" title="JAVA 写文件" itemprop="url">JAVA 写文件</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-20T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h2><p>我们使用<code>FileOutputStream</code>, <code>BufferedOutputStream</code>来读取文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedOutputStream bf = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">""</span>)));) &#123;</span><br><span class="line">	bf.write(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BufferedOutputStream 缓冲输出流。它继承于FilterOutputStream。作用是为另一个输出流提供“缓冲功能”。输出byte[]字节数组<br>BufferedOutputStream只提供了输出byte数据的方式,因此这种方式只能读取二进制流</p>
<blockquote>
<p>FileOutputStream 一个字节一个字节的向文件里输出数据</p>
</blockquote>
<h2 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h2><ol>
<li>支持字符串输出</li>
<li>支持换行输出</li>
<li>支持文件追加输出<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter writer = Files.newBufferedWriter(Paths.get(<span class="string">"new.txt"</span>), StandardCharsets.UTF_8);</span><br><span class="line">writer.write(<span class="string">"123456\n"</span>); <span class="comment">// 换行输出</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>另外还有一点需要提到的是FileWriter, 它一个字符一个字符地输出</p>
</blockquote>
<h2 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h2><p>OutputStreamWriter 将字节流转换为字符流。是字节流通向字符流的桥梁。如果不指定字符集编码，该解码过程将使用平台默认的字符编码，如：GBK。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入UTF-8格式编码的文件</span></span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">try</span> (Writer out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">		<span class="keyword">new</span> FileOutputStream(file), <span class="string">"UTF8"</span>))) &#123;</span><br><span class="line"></span><br><span class="line">	out.append(<span class="string">"Website UTF-8"</span>).append(<span class="string">"\r\n"</span>);</span><br><span class="line">	out.append(<span class="string">"中文 UTF-8"</span>).append(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line">	out.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h2><p>标准IO重定向</p>
<p>打印输出流,用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。PrintStream永远不会抛出IOException；PrintStream提供了自动flush和字符集设置功能。所谓自动flush，就是往PrintStream写入的数据会立刻调用flush()函数。</p>
<p>System类提供了一些简单的静态方法调用,以允许我们对标准输入,输出和错误IO进行重定向IO重定向是对字节流的操纵而不是字符流,因此在该例中使用的是InputStream和OutputStream而不是Reader和Writer</p>
<p>示例 如果在显示器上创建大量输出,而这些输出滚动地太快而无法阅读时,IO重定向就显得很有用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PrintStream console = System.out;</span><br><span class="line">BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Redirecting.java"</span>));</span><br><span class="line"></span><br><span class="line">PrintStream out = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"MapDB.test.out"</span>)));</span><br><span class="line"></span><br><span class="line">System.setIn(in);</span><br><span class="line">System.setOut(out);</span><br><span class="line">System.setErr(out);</span><br><span class="line"></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s;</span><br><span class="line"><span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">	System.out.println(s);</span><br><span class="line"></span><br><span class="line">out.close(); <span class="comment">// Remember this!</span></span><br><span class="line">System.setOut(console);</span><br></pre></td></tr></table></figure></p>
<h2 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h2><p>用于向文本输出流打印对象的格式化表示形式。它实现在 PrintStream 中的所有 print 方法。它不包含用于写入原始字节的方法，对于这些字节，程序应该使用未编码的字节流进行写入。</p>
<p>FileWriter可以向文件输出数据. 首先创建一个与指定文件连接的FileWriter.然后使用BufferedWriter对其进行包装进行性能提升 最后使用PrintWriter提供格式化功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file)));) &#123;</span><br><span class="line">	out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>System.out 是一个PrintStream,而PrintStream是一个OutputStream而PrintWriter有一个参数是接受OutputStream,因此我们可以将System.out转换成PrintWriter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out);) &#123;</span><br><span class="line">out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/21/JavaSE/JavaIO 写文件/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/21/JavaSE/JavaIO 写文件/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/21/JavaSE/JavaIO 序列化/" title="JAVA 序列化" itemprop="url">JAVA 序列化</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-20T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h2><p>Externalizable继承于Serializable，当使用该接口时，序列化的细节需要由程序员去完成. 如上所示的代码，由于writeExternal()与readExternal()方法未作任何处理，那么该序列化行为将不会保存/读取任何一个字段. </p>
<h2 id="Flushable"><a href="#Flushable" class="headerlink" title="Flushable"></a>Flushable</h2><p>实现了Flushable接口的类的对象，可以强制将缓存的输出写入到与对象关联的流中. 写入流的所有I/O类都实现了Flushable接口. </p>
<h2 id="ObjectInputValidation"><a href="#ObjectInputValidation" class="headerlink" title="ObjectInputValidation"></a>ObjectInputValidation</h2><p>序列化流验证机制.一般情况下，我们认为序列化流中的数据总是与最初写到流中的数据一致，这并没有问题. 但当黑客获取流信息并篡改一些敏感信息重新序列化到流中后，用户通过反序列化得到的将是被篡改的信息. Java序列化提供一套验证机制. 序列化类通过实现 java.io.ObjectInputValidation接口，就可以做到验证了</p>
<h2 id="ObjectStreamConstants"><a href="#ObjectStreamConstants" class="headerlink" title="ObjectStreamConstants"></a>ObjectStreamConstants</h2><p>Java序列化序列化对象的信息包括：类元数据描述、类的属性、父类信息以及属性域的值. Java将这些信息分成3部分：序列化头信息、类的描述部分以及属性域的值部分. 现在对a.txt文件加以分析，其中包含一些序列化机制中提供的特殊字段，这些字段被定义在java.io.ObjectStreamConstants接口中.  </p>
<h2 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h2><p>用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”</p>
<p>从DataInputStream一次一个字节地读取字符,那么任何值都是合法的,因此返回值不能用来检测输入是否结束.但是可以使用available()函数来查看还有多少字符可供读取</p>
<p>available()函数的工作方式会随之所读取的媒介类不同而不同, 该函数从字面上的意思来讲就是”在没有阻塞的情况下所能读取的字节数”.对于文件这指的是整个文件,而对于其他流可能就不是这样的</p>
<p>格式化的内存输入 当读取格式化数据时可以使用DataInputStream，它是一个面向字节的IO类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(TestDataInputStream.class.getCanonicalName())));) &#123;</span><br><span class="line">	<span class="keyword">while</span> (in.available() != <span class="number">0</span>)</span><br><span class="line">		System.out.print((<span class="keyword">char</span>) in.readByte());</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>DataInput 接口用于从二进制流中读取字节，并重构所有 Java 基本类型数据. 同时还提供根据 UTF-8 修改版格式的数据重构 String 的工具. 对于此接口中的所有数据读取例程来说，如果在读取到所需字节数的数据之前已经到达文件末尾 (end of file)，则都将抛出 EOFException（IOException 的一种）. 如果因为文件末尾以外的其他原因无法读取字节，则抛出 IOException而不是 EOFException. 尤其在输入流已关闭的情况下，将抛出 IOException. </p>
</blockquote>
<h2 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h2><p>用来装饰其它输出流，将DataOutputStream和DataInputStream输入流配合使用，“允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型”. </p>
<p>我们可以使用DataOutputStream指定格式存储数据, 然后使用DataInputStream轻松的再次指定读取格式来恢复这些数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Data.txt"</span>)));</span><br><span class="line">out.writeDouble(<span class="number">3.14159</span>);</span><br><span class="line">out.writeUTF(<span class="string">"That was pi"</span>);</span><br><span class="line">out.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">out.writeUTF(<span class="string">"Square root of 2"</span>);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Data.txt"</span>)));</span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line"><span class="comment">// Only readUTF() will recover the Java-UTF String properly:</span></span><br><span class="line">System.out.println(in.readUTF());</span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line">System.out.println(in.readUTF());</span><br><span class="line"></span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>DataOutput 接口用于将任意 Java 基本类型转换为一系列字节，并将这些字节写入二进制流. 同时还提供了一个将 String 转换成 UTF-8 修改版格式并写入所得到的系列字节的工具. 对于此接口中写入字节的所有方法，如果由于某种原因无法写入某个字节，则抛出 IOException.</p>
</blockquote>
<h2 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h2><p>用于从底层输入流中读取对象类型的数据和对象类型的数据写入到底层输出流。将对象中所有成员变量的取值保存起来就等于保存了对象，将对象中所有成员变量的取值还原就相等于读取了对象。</p>
<h2 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h2><p>用于从底层输入流中读取对象类型的数据和对象类型的数据写入到底层输出流。将对象中所有成员变量的取值保存起来就等于保存了对象，将对象中所有成员变量的取值还原就相等于读取了对象。 </p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/21/JavaSE/JavaIO 序列化/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/21/JavaSE/JavaIO 序列化/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/21/JavaSE/JavaIO 读文件/" title="JAVA 读文件" itemprop="url">JAVA 读文件</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-20T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h2><p>我们使用<code>FileInputStream</code>, <code>BufferedInputStream</code>来读取文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取二进制文件</span></span><br><span class="line"><span class="keyword">try</span> (BufferedInputStream bf = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">		<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">""</span>)));) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[bf.available()];</span><br><span class="line">	bf.read(data);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BufferedInputStream</code>是一个带有缓冲区域的<code>InputStream</code>, 支持<code>mark()</code>标记和<code>reset()</code>重置方法.输入到byte[]数组里.</p>
<p><code>BufferedInputStream</code>只将数据读取进byte字节数组里, 因此这种方式只能读取二进制字节流</p>
<blockquote>
<p>FileInputStream 一个字节一个字节的从文件里读取数据</p>
</blockquote>
<h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><p>BufferedReader 从字符输入流中读取文本,缓冲各个字符.提供字符、数组和行的高效读取.<br>我们有俩种方式创建BufferedReader.</p>
<ul>
<li>使用带缓冲区的写入器 <code>Files.newBufferedReader(Paths.get(&quot;new.txt&quot;), StandardCharsets.UTF_8);</code>;</li>
<li>读取UTF-8格式编码的文件 <code>new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))</code></li>
</ul>
<blockquote>
<p>InputStreamReader 是字节流通向字符流的桥梁：它使用指定的 charset 读写字节并将其解码为字符.将“字节输入流”转换成“字符输入流”.它继承于Reader.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = Files.newBufferedReader(Paths.get(<span class="string">"new.txt"</span>), StandardCharsets.UTF_8);</span><br><span class="line">reader.lines().forEach(line -&gt; System.out.println(line));</span><br></pre></td></tr></table></figure>
<p>我们可以使用JAVA8中的Stream来快捷的遍历每一行</p>
<blockquote>
<p>从标准IO中输入. 按照标准的IO模型,Java提供了<code>System.out, System.out, System.err System.out,System.err</code> 已经被包装成了<code>PrintStream</code>对象,但是<code>System.in</code>作为原生<code>InputStream</code>却没有进行过任何包装. 所以在使用<code>System.in</code>时必须对其进行包装,下例中展示了,我们使用<code>InputStreamReader</code>将<code>System.in</code>包装<code>Reader</code>,然后再包装一层<code>BufferedReader</code></p>
<p>另外还有一点需要提到的是FileReader, 它一个字符一个字符地读取.</p>
</blockquote>
<h2 id="LineNumberInputStream"><a href="#LineNumberInputStream" class="headerlink" title="LineNumberInputStream"></a>LineNumberInputStream</h2><p>此类是一个输入流过滤器,它提供跟踪当前行号的附加功能.行是以回车符 (<code>\r</code>)、换行符 (<code>\n</code>)或回车符后面紧跟换行符结尾的字节序列.在所有这三种情况下,都以单个换行符形式返回行终止字符.行号以 0 开头,并在 read 返回换行符时递增 1.</p>
<h2 id="LineNumberReader"><a href="#LineNumberReader" class="headerlink" title="LineNumberReader"></a>LineNumberReader</h2><p>跟踪行号的缓冲字符输入流.此类定义了方法 <code>setLineNumber(int)</code> 和 <code>getLineNumber()</code>,它们可分别用于设置和获取当前行号.默认情况下,行编号从 0 开始.该行号随数据读取在每个行结束符处递增,并且可以通过调用 <code>setLineNumber(int)</code> 更改行号.但要注意的是,<code>setLineNumber(int)</code> 不会实际更改流中的当前位置；它只更改将由<code>getLineNumber()</code>返回的值.可认为行在遇到以下符号之一时结束：换行符（<code>\n</code>）、回车符（<code>\r</code>）、回车后紧跟换行符.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  获取行数</span></span><br><span class="line"><span class="keyword">int</span> lineCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> (FileReader reader = <span class="keyword">new</span> FileReader(IOUtils.newFile(<span class="string">""</span>));</span><br><span class="line">		LineNumberReader lnr = <span class="keyword">new</span> LineNumberReader(reader);) &#123;</span><br><span class="line">	<span class="keyword">while</span> (lnr.readLine() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		lineCount++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><p>读写随机访问文件 <code>RandomAccessFile</code>除了实现了<code>DataInput</code>和<code>DataOutput</code>接口之外,有效地与IO继承层次结构的其他部分实现了分离.</p>
<p>因为它不支持装饰模式,所以不能将其与<code>InputStream</code>和<code>OutputStream</code>子类的任何部分组合起来而且必须假定<code>RandomAccessFile</code>已经被正确的缓冲</p>
<p>用来访问那些保存数据记录的文件的,你就可以用<code>seek()</code>方法来访问记录,并进行读写了.这些记录的大小不必相同；但是其大小和位置必须是可知的.但是该类仅限于操作文件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取所有的行</span></span><br><span class="line"><span class="keyword">try</span> (RandomAccessFile r = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>)) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length(); i++) &#123;</span><br><span class="line">		r.read();	<span class="comment">// r.readLine();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据,第二个参数必须为 "r", "rw", "rws", or "rwd"</span></span><br><span class="line"><span class="keyword">try</span> (RandomAccessFile w = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>)) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>; i++)</span><br><span class="line">		w.writeByte(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (FileChannel fc = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"temp.tmp"</span>), <span class="string">"rw"</span>)</span><br><span class="line">		.getChannel();) &#123;</span><br><span class="line"></span><br><span class="line">	IntBuffer ib = fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, fc.size())</span><br><span class="line">			.asIntBuffer();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">		ib.put(ib.get(i - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"temp.tmp"</span>), <span class="string">"rw"</span>);</span><br><span class="line">raf.writeInt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">	raf.seek(raf.length() - <span class="number">4</span>);</span><br><span class="line">	raf.writeInt(raf.readInt());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure></p>
<h2 id="getResourceAsStream"><a href="#getResourceAsStream" class="headerlink" title="getResourceAsStream"></a>getResourceAsStream</h2><p>我们还可以使用类加载器的<code>getResourceAsStream()</code>从指定路径或者jar包中加载文件资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = ReloadClass.class.getClassLoader().getResourceAsStream(path);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[input.available()];</span><br><span class="line">	input.read(bytes);</span><br><span class="line">	<span class="keyword">return</span> bytes;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/21/JavaSE/JavaIO 读文件/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/21/JavaSE/JavaIO 读文件/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/21/JavaSE/JavaIO 文件操作/" title="JAVA 文件操作" itemprop="url">JAVA 文件操作</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-20T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="FileFilter"><a href="#FileFilter" class="headerlink" title="FileFilter"></a>FileFilter</h2><p>检测文件是否存在.FileFilter 和他的前身FilenameFilter 唯一的不同是FileFilter 提供文件对象的访问方法,而FilenameFilter 是按照目录和文件名的方式来工作的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileFilter fileFilter = pathname -&gt; &#123;</span><br><span class="line">	System.out.println(pathname.getPath());</span><br><span class="line">	<span class="keyword">return</span> pathname.isFile();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fileFilter.accept(<span class="keyword">new</span> File(<span class="string">"D:\\hazelcast-documentation-3.5.3.pdf"</span>));</span><br></pre></td></tr></table></figure></p>
<h2 id="FilenameFilter"><a href="#FilenameFilter" class="headerlink" title="FilenameFilter"></a>FilenameFilter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FilenameFilter filenameFilter = (dir, name) -&gt; &#123;</span><br><span class="line">	System.out.println(dir);</span><br><span class="line">	System.out.println(name);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">filenameFilter.accept(<span class="keyword">new</span> File(<span class="string">"D"</span>), <span class="string">"hazelcast-documentation-3.5.3.pdf"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>File对象给我们提供了以下的功能</p>
<ul>
<li>删除文件</li>
<li>文件重命名</li>
<li>创建新的文件</li>
<li>创建新的文件</li>
<li>获取文件的最后修改时间</li>
<li>设置文件只读</li>
<li>设置文件可写</li>
<li>获取文件长度(总字节数)</li>
<li>获取文件路径</li>
<li>获取绝对文件路径</li>
<li>文件是否隐藏</li>
<li>获得剩余磁盘空间？</li>
<li>拷贝文件夹</li>
<li>遍历文件夹</li>
<li>检查文件夹是否为空？</li>
</ul>
<h2 id="FileDescriptor"><a href="#FileDescriptor" class="headerlink" title="FileDescriptor"></a>FileDescriptor</h2><p>用来表示开放文件、开放套接字等.当FileDescriptor表示某文件时,我们可以通俗的将FileDescriptor看成是该文件.但是,我们不能直接通过FileDescriptor对该文件进行操作；若需要通过FileDescriptor对该文件进行操作,则需要新创建FileDescriptor对应的FileOutputStream,再对文件进行操作.</p>
<p>类实例作为一个不透明的句柄底层机器特有的结构表示一个打开的文件,打开的套接字或其他来源或字节的接收器.以下是关于FileDescriptor要点：</p>
<ol>
<li>主要实际使用的文件描述符是创建一个FileInputStream或FileOutputStream来遏制它.</li>
<li>应用程序不应创建自己的文件描述符.</li>
</ol>
<h2 id="FileLock"><a href="#FileLock" class="headerlink" title="FileLock"></a>FileLock</h2><p>锁定文件</p>
<p>ByteBuffer.allocate()语句改为ByteBuffer.allocateDirect().用来证实性能之间的差异,但是请注意程序的启动时间是否发生了明显的改变.</p>
<p>修改{@link JGrep}让其使java的nio内存映射文件.</p>
<p>JDK1.4引入了文件加锁机制,它允许我们同步访问某个作为共享资源的文件.不过,竞争同一文件的两个线程可能在不同的Java虚拟机上;或者一个是Java线程,另一个是操作系统中其他的某个本地线程.</p>
<p>文件锁对其他的操作系统进程是可见的,因为Java的文件加锁直接映射到了本地操作系统的加锁工具.通过对FileChannel调用tryLock()或lock(),就可以获得整个文件的FileLock.</p>
<p>(SocketChannel、DatagramChannel和 ServerSocketChannel不需要加锁,因为他们是从单进程实体继承而来;我们通常不在两个进程之间共享网络socket.)</p>
<p>tryLock()是非阻塞式的,它设法获取锁,但是如果不能获得(当其他一些进程已经持有相同的锁,并且不共享时),它将直接从方法调用返回.lock()则是阻塞式的,它要阻塞进程直至锁可以获得,或调用lock()的线程中断,或调用lock()的通道关闭.</p>
<p>使用FileLock.release()可以释放锁.</p>
<p>也可以使用此方法对文件上锁tryLock()或者lock()其中,加锁的区域由size-position决定.第三个参数指定是否是共享锁.</p>
<p>尽管无参数的加锁方法将根据文件尺寸的变化而变化,但是具有固定尺寸的锁不随文件尺寸的变化而变化.如果你获得了某一区域(从position到position+size)上的锁,当文件增大超出position+size时,那么在position+size之外的部分不会被锁定.无参数的加锁方法会对 整个文件进行加锁,甚至文件变大后也是如此.</p>
<p>对独占锁或者共享锁的支持必须由底层的操作系统提供.如果操作系统不支持共享锁并为每一个请求都创建一个锁,那么它就会使用独占锁.</p>
<p>锁的 类型(共享或独占)可以通过FileLock.isShared()进行查询.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"file.txt"</span>);</span><br><span class="line">FileLock fl = fos.getChannel().tryLock();</span><br><span class="line"><span class="keyword">if</span> (fl != <span class="keyword">null</span>) &#123;</span><br><span class="line">	System.out.println(<span class="string">"Locked File"</span>);</span><br><span class="line">	TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">	fl.release();</span><br><span class="line">	System.out.println(<span class="string">"Released Lock"</span>);</span><br><span class="line">&#125;</span><br><span class="line">fos.close()</span><br></pre></td></tr></table></figure></p>
<h2 id="DirectoryStream"><a href="#DirectoryStream" class="headerlink" title="DirectoryStream"></a>DirectoryStream</h2><p>遍历某个文件夹内的所有文件,但是不会遍历子目录. 也就是这会遍历当前路径中的所有文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DirectoryStream&lt;Path&gt; paths = Files.newDirectoryStream(Paths.get(<span class="string">"E:"</span>));</span><br><span class="line">paths.forEach(path -&gt; &#123;</span><br><span class="line">	System.out.println(path.getFileName());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>SecureDirectoryStream</p>
</blockquote>
<h2 id="FileVisitor"><a href="#FileVisitor" class="headerlink" title="FileVisitor"></a>FileVisitor</h2><p>遍历某个文件夹内的所有文件接口.</p>
<p><code>SimpleFileVisitor</code>实现了这个接口. 与<code>DirectoryStream</code> 不同的是,这个类会遍历目录下包括子目录的所有文件并且提供了多种处理接口方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SimpleFileVisitor visitor = <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">				System.out.println(file.getFileName());</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		Files.walkFileTree(Paths.get(<span class="string">"E:"</span>), visitor);</span><br></pre></td></tr></table></figure></p>
<h2 id="监控文件变化"><a href="#监控文件变化" class="headerlink" title="监控文件变化"></a>监控文件变化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WatchService service = FileSystems.getDefault().newWatchService();</span><br><span class="line">		Paths.get(<span class="string">"D:/"</span>).register(service,</span><br><span class="line">		ENTRY_CREATE,</span><br><span class="line">		ENTRY_DELETE,</span><br><span class="line">		ENTRY_MODIFY);</span><br><span class="line"></span><br><span class="line">WatchKey watchKey = service.take();</span><br><span class="line"></span><br><span class="line">watchKey.pollEvents().stream().forEach(watchEvent -&gt; &#123;</span><br><span class="line">	System.out.println(watchEvent.context() + <span class="string">"  "</span> + watchEvent.kind());</span><br><span class="line">&#125;);</span><br><span class="line">watchKey.reset();</span><br></pre></td></tr></table></figure>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><ol>
<li>copy</li>
<li>createDirectories</li>
<li>createDirectory</li>
<li>createFile</li>
<li>createLink</li>
<li>createSymbolicLink</li>
<li>createTempDirectory</li>
<li>createTempFile</li>
<li>delete</li>
<li>deleteIfExists</li>
<li>exists</li>
<li>getAttribute</li>
<li>getFileAttributeView</li>
<li>getFileStore</li>
<li>getLastModifiedTime</li>
<li>getOwner</li>
<li>getPosixFilePermissions</li>
<li>isDirectory</li>
<li>isExecutable</li>
<li>isHidden</li>
<li>isReadable</li>
<li>isRegularFile</li>
<li>isSameFile</li>
<li>isSymbolicLink</li>
<li>isWritable</li>
<li>move</li>
<li>newBufferedReader</li>
<li>newBufferedWriter</li>
<li>newByteChannel</li>
<li>newDirectoryStream</li>
<li>newInputStream</li>
<li>newOutputStream</li>
<li>notExists</li>
<li>probeContentType</li>
<li>readAllBytes</li>
<li>readAllLines</li>
<li>readAttributes</li>
<li>readSymbolicLink</li>
<li>setAttribute</li>
<li>setLastModifiedTime</li>
<li>setOwner</li>
<li>setPosixFilePermissions</li>
<li>walkFileTree</li>
<li>write</li>
</ol>
<h2 id="FileStore"><a href="#FileStore" class="headerlink" title="FileStore"></a>FileStore</h2><p>代表了真正的存储设备,提供了设备的详尽信息</p>
<h2 id="FileSystems"><a href="#FileSystems" class="headerlink" title="FileSystems"></a>FileSystems</h2><ul>
<li>FileSystems.getDefault() ：返回 JVM 默认的 FileSystem – 一般说来,也就是操作系统的默认文件系统</li>
<li>FileSystems.getFileSystem(uri) ： 可以获取远程主机的FileSystem<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileSystem system = FileSystems.getDefault();</span><br><span class="line"><span class="comment">// 得到文件系统支持的属性视图列表</span></span><br><span class="line">Set&lt;String&gt; views = system.supportedFileAttributeViews();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>FileSystem</p>
</blockquote>
<h2 id="Paths"><a href="#Paths" class="headerlink" title="Paths"></a>Paths</h2><blockquote>
<p>Path 类可以在任何文件系统（FileSystem）和任何存储空间 Path 类引用默认文件系统（计算机的文件系统）的文件,但是 NIO.2是完全模块化的—— FileSystem 的具体实现是在内存中的一组数据,因此在网络环境或在虚拟文件系统中,NIO.2 也完全适用.NIO.2提供给我们在文件系统中操作文件、文件夹或链接的所有方法</p>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/21/JavaSE/JavaIO 文件操作/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/21/JavaSE/JavaIO 文件操作/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/21/JavaSE/JavaIO 内存IO/" title="JAVA 内存IO" itemprop="url">JAVA 内存IO</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-20T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h2><p>从byte[]数组中读取数据到缓存中.可以将字节数组转化为输入流此类中的方法在关闭此流后仍可被调用，而不会产生任何 <code>IOException</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] buff = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">try</span>(ByteArrayInputStream in = <span class="keyword">new</span> ByteArrayInputStream(buff)) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(in.available() != <span class="number">0</span>)</span><br><span class="line">		System.out.println(in.read());</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h2><p>输出数据到byte[]数组里，可以捕获内存缓冲区的数据，转换成字节数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray()和 toString()获取数据。    关闭 <code>ByteArrayOutputStream</code>无效。此类中的方法在关闭此流后仍可被调用，而不会产生任何<code>IOException</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] buff = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">try</span>(ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">	out.write(buff);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">byte</span>[] byteArray = out.toByteArray();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">byte</span> b : byteArray) &#123;</span><br><span class="line">		System.out.println(<span class="string">"flush before : "</span> + b);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	out.flush();</span><br><span class="line"></span><br><span class="line">	byteArray = out.toByteArray();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">byte</span> b : byteArray) &#123;</span><br><span class="line">		System.out.println(<span class="string">"flush after : "</span> + b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CharArrayReader"><a href="#CharArrayReader" class="headerlink" title="CharArrayReader"></a>CharArrayReader</h2><p>与ByteArrayInputStream对应。 支持mark和reset读取char[] 数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] array = &#123;<span class="string">'a'</span>, <span class="string">'z'</span>, <span class="string">'g'</span>&#125;;</span><br><span class="line"><span class="keyword">try</span>(CharArrayReader in = <span class="keyword">new</span> CharArrayReader(array)) &#123;</span><br><span class="line">	<span class="keyword">while</span>(in.ready())</span><br><span class="line">		System.out.println(in.read());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CharArrayWriter"><a href="#CharArrayWriter" class="headerlink" title="CharArrayWriter"></a>CharArrayWriter</h2><p>向内部char[] 缓冲区存储数据.  支持rest, 文件追加写操作, 支持string write<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(CharArrayWriter out = <span class="keyword">new</span> CharArrayWriter()) &#123;</span><br><span class="line">	out.write(<span class="string">"TestChararray"</span>);</span><br><span class="line">	System.out.println(out.toString());</span><br><span class="line">	out.append(<span class="string">"test_"</span>);</span><br><span class="line">	System.out.println(out.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="PushbackInputStream"><a href="#PushbackInputStream" class="headerlink" title="PushbackInputStream"></a>PushbackInputStream</h2><p>拥有一个PushBack缓冲区，从PushbackInputStream读出数据后，只要PushBack缓冲区没有满，就可以使用unread()将数据推回流的前端。</p>
<h2 id="PushbackReader"><a href="#PushbackReader" class="headerlink" title="PushbackReader"></a>PushbackReader</h2><p>允许将字符推回到流的字符流 reader。当程序调用推回输入流的unread()方法时，系统会把指定数组的内容推回到该缓冲区中，而推回输入流每次调用read()方法时，总是先从推回缓冲区读取内容，只有完全读取了推回缓冲区里的内容后，但是还没有装满read()所需要的数组时才会从原输入流中读取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line"><span class="comment">// 创建一个PushbackReader对象，指定推回缓冲区的长度为64</span></span><br><span class="line">PushbackReader pr = <span class="keyword">new</span> PushbackReader(<span class="keyword">new</span> FileReader(<span class="string">"PushBackTest.java"</span>), <span class="number">64</span>);</span><br><span class="line"><span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];</span><br><span class="line"><span class="comment">// 用以保存上次读取字符串的内容</span></span><br><span class="line">String lastContent = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取文件内容</span></span><br><span class="line"><span class="keyword">while</span> ((hasRead = pr.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">// 将读取的内容转化为字符串</span></span><br><span class="line">	String content = <span class="keyword">new</span> String(buf, <span class="number">0</span>, hasRead);</span><br><span class="line">	<span class="keyword">int</span> targetIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将上次读取的字符串和本次读取的字符串拼接起来</span></span><br><span class="line">	<span class="comment">// 查看是否包含目标字符串，</span></span><br><span class="line">	<span class="comment">// 如果包含目标字符串</span></span><br><span class="line">	<span class="keyword">if</span> ((targetIndex = (lastContent + content)</span><br><span class="line">			.indexOf(<span class="string">"new PushbackReader"</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 将本次的内容和上次的内容一起推回缓冲区</span></span><br><span class="line">		pr.unread((lastContent + content).toCharArray());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重现定义一个长度为targetIndex的char类型的数组</span></span><br><span class="line">		<span class="keyword">if</span> (targetIndex &gt; <span class="number">32</span>) &#123;</span><br><span class="line">			buf = <span class="keyword">new</span> <span class="keyword">char</span>[targetIndex];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 再次读取指定长度的内容，即目标字符串之前的内容</span></span><br><span class="line">		pr.read(buf, <span class="number">0</span>, targetIndex);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 答应读取指定长度的内容</span></span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(buf, <span class="number">0</span>, targetIndex));</span><br><span class="line">		System.exit(<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 打印上次读取的内容</span></span><br><span class="line">		System.out.println(lastContent);</span><br><span class="line">		<span class="comment">// 将本次读取的内容设置为上次读取的内容</span></span><br><span class="line">		lastContent = content;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="PipedReader"><a href="#PipedReader" class="headerlink" title="PipedReader"></a>PipedReader</h2><p>PipedWriter 是字符管道输出流,可以通过管道进行线程间的通讯。</p>
<h2 id="PipedWriter"><a href="#PipedWriter" class="headerlink" title="PipedWriter"></a>PipedWriter</h2><p>PipedReader 是字符管道输入流,可以通过管道进行线程间的通讯。</p>
<h2 id="PipedInputStream"><a href="#PipedInputStream" class="headerlink" title="PipedInputStream"></a>PipedInputStream</h2><p>管道输入流是让多线程可以通过管道进行线程间的通讯</p>
<h2 id="PipedOutputStream"><a href="#PipedOutputStream" class="headerlink" title="PipedOutputStream"></a>PipedOutputStream</h2><p>管道输出流是让多线程可以通过管道进行线程间的通讯</p>
<h2 id="SequenceInputStream"><a href="#SequenceInputStream" class="headerlink" title="SequenceInputStream"></a>SequenceInputStream</h2><p>从多个输入流中向程序读入数据。此时，可以使用合并流，将多个输入流合并成一个SequenceInputStream流对象。SequenceInputStream会将与之相连接的流集组合成一个输入流并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末 尾为止。 合并流的作用是将多个源合并合一个源。</p>
<h2 id="StreamTokenizer"><a href="#StreamTokenizer" class="headerlink" title="StreamTokenizer"></a>StreamTokenizer</h2><p>获取输入流并将其解析为“标记”，允许一次读取一个标记。解析过程由一个表和许多可以设置为各种状态的标志控制。该流的标记生成器可以识别标识符、数字、引用的字符串和各种注释样式等。</p>
<h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><p>专用来访问基于字符的控制台设备。如果你的Java程序要与Windows下的cmd或者Linux下的Terminal交互，就可以用这个Java Console类java.io.Console 只能用在标准输入、输出流未被重定向的原始控制台中使用，在 Eclipse 或者其他 IDE 的控制台是用不了的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Console cons = System.console();</span><br><span class="line"><span class="keyword">if</span> (cons != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">// -------------------------</span></span><br><span class="line">	PrintWriter printWriter = cons.writer();</span><br><span class="line">	printWriter.write(<span class="string">"input:"</span>);</span><br><span class="line">	cons.flush();</span><br><span class="line">	String str1 = cons.readLine();</span><br><span class="line">	cons.format(<span class="string">"%s"</span>, str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/21/JavaSE/JavaIO 内存IO/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/21/JavaSE/JavaIO 内存IO/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/20/netty/ByteBuf/" title="Netty ByteBuf" itemprop="url">Netty ByteBuf</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-19T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>首先我们来看一下netty buffer包的继承结构<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/netty/bytebuf.jpg" alt=""><br>接下来我会对几个类进行代码测试.</p>
<p>首先我们来看一下如何使用Netty提供的工具类构建一个ByteBuf<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">1024</span>, buf.capacity());</span><br></pre></td></tr></table></figure></p>
<p>我们使用<code>ByteBufAllocator</code>这个工具类构建了一个<code>1024</code>大小的<code>ByteBuf</code>出来.</p>
<p>ByteBuf提供了 <code>readerIndex</code> 和 <code>writerIndex</code> 进行缓冲区的顺序读写操作.</p>
<ul>
<li><code>readerIndex</code>标志读取索引</li>
<li><code>writerIndex</code>标志写入索引</li>
<li>[0, readerIndex] 已经读取多的缓冲区区间</li>
<li>[readerIndex, writerIndex] 可读的缓冲区区间</li>
<li>[writerIndex, capacity]  可写的缓冲区区间</li>
</ul>
<blockquote>
<p>每个索引移动的单位是<code>bytes</code>, 在下例中我们向ByteBuf写入一个int数值, <code>writerIdex</code>会移动4个<code>bytes</code></p>
</blockquote>
<h2 id="ByteBuf-API"><a href="#ByteBuf-API" class="headerlink" title="ByteBuf API"></a>ByteBuf API</h2><p>我们首先看一下ByteBuf提供的API</p>
<h3 id="ByteBuf-write"><a href="#ByteBuf-write" class="headerlink" title="ByteBuf write"></a>ByteBuf write</h3><p>接下来我们看一下向ByteBuf缓冲区写入数据的API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeInt(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 写入一个Int数值, writerIndex向后移动4个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeChar(<span class="string">'a'</span>);</span><br><span class="line">	<span class="comment">// 写入一个Char字符, writerIndex向后移动2个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">100</span>&#125;;</span><br><span class="line">	buf.writeBytes(bytes);</span><br><span class="line">	<span class="comment">// 写入一个byte数组, 由于byte数组只有一个元素, writerIndex向后移动1个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBytesWithStartEndIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">100</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">	buf.writeBytes(bytes, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 我们将三个元素的byte数组写入ByteBuf中,但是在写入的时候我们指定了开始索引和结束索引,</span></span><br><span class="line">	<span class="comment">// 由于我们的开始索引和结束索引相等, 因此ByteBuf中只写入了1这个元素</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBytes3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf1.writeInt(<span class="number">1</span>);</span><br><span class="line">	buf.writeBytes(buf1);</span><br><span class="line">	<span class="comment">// 我们向ByteBuf中写入另一个ByteBuf, 它的索引仍然是增长4. ByteBuf不仅仅可以写入BuyeBuf,还可以写入InputStream和ByteBuffer</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeFloat(<span class="number">0.1f</span>);</span><br><span class="line">	<span class="comment">// 写入一个float, 由于float也是占用4个字节, 因此writerIndex向后移动4个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeByte(<span class="number">1</span>);</span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.writerIndex());</span><br><span class="line">	buf.writeByte(<span class="number">1000</span>);</span><br><span class="line">	<span class="comment">// 写入一个byte, writerIndex向后移动1个字节,至于写进去的数字大于128,会发生什么,我们在read的时候看一下结果</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeShort(<span class="number">1000</span>);</span><br><span class="line">	<span class="comment">// 写入一个short, writerIndex向后移动2个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeDouble(<span class="number">1000.0</span>d);</span><br><span class="line">	<span class="comment">// 写入一个double, writerIndex向后移动8个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">8</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBoolean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBoolean(<span class="keyword">false</span>);</span><br><span class="line">	<span class="comment">// 写入一个boolean, writerIndex向后移动1个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeLong(<span class="number">100l</span>);</span><br><span class="line">	<span class="comment">// 写入一个long, writerIndex向后移动8个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">8</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteOverLoadMaxCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">	buf.writeBytes(<span class="string">"123456"</span>.getBytes());</span><br><span class="line">	<span class="comment">// 虽然在分配的时候我们只分配了5个字节大小的缓冲区,但是我们写入6个字节它也并不报错,</span></span><br><span class="line">	<span class="comment">// 而且我们观察到writerIndex确实增长到了6,说明ByteBuf会进行自动拓容.</span></span><br><span class="line">	Assert.assertEquals(<span class="number">6</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ByteBuf-read"><a href="#ByteBuf-read" class="headerlink" title="ByteBuf read"></a>ByteBuf read</h3><p>刚才我们看了向ByteBuf缓冲区写入数据的API,接下来我们看一下从ByteBuf缓冲区读取数据的API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeInt(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> read = buf.readInt();</span><br><span class="line">	<span class="comment">// 读取Int, readerIndex向后移动4字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeChar(<span class="string">'1'</span>);</span><br><span class="line">	<span class="keyword">char</span> read = buf.readChar();</span><br><span class="line">	<span class="comment">// 读取Char, readerIndex向后移动2字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="string">'1'</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">byte</span>[] read = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">	buf.readBytes(read);</span><br><span class="line">	<span class="comment">// 读取byte数组, 这里需要注意的是, read字节数组的长度不能大于ByteBuf的readerIndex的值,否则会产生数组越界</span></span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">0</span>, read[<span class="number">9</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadBytesWithStartEndIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">byte</span>[] read = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">	buf.readBytes(read, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 从第三个索引开始读取到第4个索引的位置, 读取2个字节, readerIndex移动到第4个索引位置上</span></span><br><span class="line">	Assert.assertEquals(<span class="number">3</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">3</span>, read[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead3Bytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	buf.readBytes(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 读取3个字节, readerIndex向后移动3字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">3</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeFloat(<span class="number">10.0f</span>);</span><br><span class="line">	<span class="keyword">float</span> read = buf.readFloat();</span><br><span class="line">	<span class="comment">// 读取Float, readerIndex向后移动4字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>.f, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeLong(<span class="number">10l</span>);</span><br><span class="line">	buf.readLong();</span><br><span class="line">	<span class="comment">// 读取long, readerIndex向后移动8字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">8</span>, buf.readerIndex());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	buf.readByte();</span><br><span class="line">	<span class="comment">// 读取byte, readerIndex向后移动1字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeShort(<span class="number">10</span>);</span><br><span class="line">	buf.readShort();</span><br><span class="line">	<span class="comment">// 读取short, readerIndex向后移动2字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadBoolean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">	buf.readBoolean();</span><br><span class="line">	<span class="comment">// 读取boolean, readerIndex向后移动1字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeDouble(<span class="number">10.0</span>d);</span><br><span class="line">	buf.readDouble();</span><br><span class="line">	<span class="comment">// 读取double, readerIndex向后移动8字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">8</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadUnsignedByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeByte(-<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">short</span> read = buf.readUnsignedByte();</span><br><span class="line">	<span class="comment">// 读取无符号byte, readerIndex向后移动1字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">246</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadUnsignedShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeShort(-<span class="number">1024</span>);</span><br><span class="line">	<span class="comment">// 我们首先读取出-1024,这个负数,然后转化成无符号数字64512</span></span><br><span class="line">	<span class="keyword">int</span> read = buf.readUnsignedShort();</span><br><span class="line">	<span class="comment">// 读取无符号Short, readerIndex向后移动2字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">64512</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReaderIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	Assert.assertEquals(<span class="number">0</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadableBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>, buf.readableBytes());</span><br><span class="line">	buf.readByte();</span><br><span class="line">	<span class="comment">// 我们读取一个byte之后, 可读取字节变成了9个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">9</span>, buf.readableBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadUnsignedInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeInt(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">long</span> read = buf.readUnsignedInt();</span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadSlice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	ByteBuf read = buf.readSlice(<span class="number">5</span>);</span><br><span class="line">	<span class="comment">// slice出来的ByteBuf与原ByteBuf共享缓冲区</span></span><br><span class="line">	Assert.assertEquals(<span class="number">5</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, read.readByte());</span><br><span class="line">	Assert.assertEquals(<span class="number">6</span>, buf.readByte());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBytesReadInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">int</span> read = buf.readInt();</span><br><span class="line">	<span class="comment">// 从一个byte数组中读取一个int, 会读取出1, 2, 3, 4这四个byte转换成int为16909060</span></span><br><span class="line">	Assert.assertEquals(<span class="number">16909060</span>, read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="discard-bytes"><a href="#discard-bytes" class="headerlink" title="discard bytes"></a>discard bytes</h3><p>在前面的测试中我们看到了,当向ByteBuf写入数据时,当超出分配内存大小时,ByteBuf会进行自动拓容(重新生成一个数组缓冲区,然后将原先的缓冲区内容拷贝到新的缓冲区中),这样一来ByteBuf占用的内从会越来越大. 我们可以是<code>discardReadBytes()</code>这个方法重用以前的缓冲区, 它会将[0, readerIndex]区间的内存舍弃掉(内部也是数组复制), 这么着就节间的重用了以前的缓冲区,但是这种方式有一点就是如果频繁的调用这个方法会带来性能问题.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">buf.writeBytes(<span class="string">"123456789"</span>.getBytes());</span><br><span class="line">buf.readBytes(<span class="number">3</span>);	<span class="comment">// 读取三个字节</span></span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 3</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 9</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 9 - 3 = 6</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 50 - 9 = 41</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 舍弃已读字节, readerIndex重置为0</span></span><br><span class="line">buf.discardReadBytes();</span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 0</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 6</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 6</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 50 - 6 = 44</span></span><br></pre></td></tr></table></figure></p>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>这个操作并不会情况缓冲区的内容只是用来将readerIndex和writerIndex重置为0. 但是缓冲区的内容我们是仍然可以读到的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">buf.writeBytes(<span class="string">"123456789"</span>.getBytes());</span><br><span class="line">buf.readBytes(<span class="number">3</span>);	<span class="comment">// 读取三个字节</span></span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 3</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 9</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 9 - 3 = 6</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 50 - 9 = 41</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置readerIndex和writerIndex</span></span><br><span class="line">buf.clear();</span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 0</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 0</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 readerIndex = 0</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 capacity - writerIndex = 50</span></span><br><span class="line"><span class="comment">// 设置writerIndex</span></span><br><span class="line">buf.writerIndex(<span class="number">6</span>);</span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 0</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 6</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 writerIndex - readerIndex = 6</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 44</span></span><br><span class="line">System.out.println(buf.readByte());</span><br></pre></td></tr></table></figure></p>
<h3 id="mark-reset"><a href="#mark-reset" class="headerlink" title="mark reset"></a>mark reset</h3><p>mark reset相关的四个方法也是对指针位置的操作</p>
<ul>
<li><code>markReaderIndex()</code> 记录readerIndex</li>
<li><code>markWriterIndex()</code> 记录writerIndex</li>
<li><code>resetReaderIndex()</code>  将记录的readerIndex重置到当前的readerIndex值</li>
<li><code>resetWriterIndex()</code>  将记录的writerIndex重置到当前的writerIndex值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReaderIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">	buf.writeBytes(<span class="string">"123456789"</span>.getBytes());</span><br><span class="line">	buf.readBytes(<span class="number">3</span>);</span><br><span class="line">	buf.markReaderIndex();</span><br><span class="line">	buf.readBytes(<span class="number">1</span>);</span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.readerIndex());</span><br><span class="line">	buf.resetReaderIndex();</span><br><span class="line">	Assert.assertEquals(<span class="number">3</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriterIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">	buf.writeBytes(<span class="string">"123456789"</span>.getBytes());</span><br><span class="line">	buf.markWriterIndex();</span><br><span class="line">	buf.writeByte(<span class="number">1</span>);</span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>, buf.writerIndex());</span><br><span class="line">	buf.resetWriterIndex();</span><br><span class="line">	Assert.assertEquals(<span class="number">9</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>ByteBuf提供丰富的API让我查找某个Byte<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定的范围内查找某个byte</span></span><br><span class="line"><span class="keyword">int</span> idx = buf.indexOf(<span class="number">0</span>, buf.writerIndex(), (<span class="keyword">byte</span>)<span class="number">2</span>);</span><br><span class="line">System.out.println(idx);	<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">idx = buf.indexOf(<span class="number">3</span>, buf.writerIndex(), (<span class="keyword">byte</span>)<span class="number">2</span>);</span><br><span class="line">System.out.println(idx);	<span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在[readerIndex, writerIndex]之间查找值</span></span><br><span class="line">idx = buf.bytesBefore((<span class="keyword">byte</span>)<span class="number">2</span>);</span><br><span class="line">System.out.println(idx);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">buf.readBytes(<span class="number">3</span>);</span><br><span class="line">idx = buf.bytesBefore((<span class="keyword">byte</span>)<span class="number">2</span>);</span><br><span class="line">System.out.println(idx); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在[readerIndex, writerIndex]之间遍历查找值</span></span><br><span class="line">idx = buf.forEachByte(b -&gt; b == (<span class="keyword">byte</span>) <span class="number">6</span>);</span><br><span class="line">System.out.println(idx); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="derived-buffers"><a href="#derived-buffers" class="headerlink" title="derived buffers"></a>derived buffers</h3><p>ByteBuf提供多种API用于创建某个ByteBuf的视图或者复制版本</p>
<ul>
<li><code>duplicate()</code> 复制ByteBuf对象, 俩个对象共享同一个缓冲区,但是各自维护自己的索引(readerIndex, writerIndex)</li>
<li><code>copy()</code> 复制ByteBuf对象, 俩个对象共享有自己的缓冲区, 缓冲区和索引都不共享</li>
<li><code>slice()</code>  复制Bytebuf对象,但是只复制[readerIndex, writerIndex]区间的缓冲区, 俩个对象的缓冲区是共享的,但是维护各自的索引</li>
</ul>
<h3 id="get-set"><a href="#get-set" class="headerlink" title="get set"></a>get set</h3><p>ByteBuf不仅仅支持read, write的顺序读写还支持get,set的随机读取。 但是get/set不会进行自动拓容.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b = buf.getByte(<span class="number">2</span>);</span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 9</span></span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// 0</span></span><br><span class="line">System.out.println(b);		<span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><p>Netty的内存池由<code>PoolArea</code>. <code>PoolArea</code>由多个<code>PoolChunk</code>组成. </p>
<h2 id="ButeBuf-类型"><a href="#ButeBuf-类型" class="headerlink" title="ButeBuf 类型"></a>ButeBuf 类型</h2><p>看完ByteBuf的API操作我们来看一下ByteBuf的分类,在内存使用种类上ByteBuf分为以下俩类</p>
<ul>
<li>DirectByteBuf : 使用JVM堆外内存分配. 虽然分配和回收速度慢一些,但是从SocketChannel中写入或者读取数据由于少了一次内存复制,因此速度较快.(SocketIO通信时适合使用)</li>
<li>HeapByteBuf: 使用JVM堆内内存分配. 内存分配和回收速度较快,但是读写Socket IO的时候由于会额外进行一次内存复制,堆内存对应的缓冲区复制到内核Channel中,性能会有下降.(后端业务在编解码时适合使用)</li>
</ul>
<p>在内存使用种类上由分为以下俩类</p>
<ul>
<li>PooledByteBuf: 基于内存对象池的ByteBuf, </li>
<li>UnpooledByteBuf: </li>
</ul>
<blockquote>
<p>UnpooledDirectByteBuf, UnpooledHeapByteBuf, UnpooledUnsafeDirectByteBuf ,PooledDirectByteBuf, PooledHeapByteBuf</p>
</blockquote>
<h2 id="AbstractByteBuf"><a href="#AbstractByteBuf" class="headerlink" title="AbstractByteBuf"></a>AbstractByteBuf</h2><p><code>AbstractByteBuf</code>继承自<code>ByteBuf</code>, 它内部并没有定义ByteBuf的缓冲区实现,只是通过定义<code>readerIndex</code>, <code>writerIndex</code>, <code>capacity</code>等实现ByteBuf接口中的各种API, 具体的缓冲区实现则由子类实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ResourceLeakDetector&lt;ByteBuf&gt; leakDetector = <span class="keyword">new</span> ResourceLeakDetector&lt;ByteBuf&gt;(ByteBuf.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> readerIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> writerIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedReaderIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedWriterIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxCapacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SwappedByteBuf swappedBuf;</span><br></pre></td></tr></table></figure></p>
<p>除了操作具体缓冲区API没有实现之外 <code>AbstractByteBuf</code>为我们实现了大量的API,首先我们看一下读数据的API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readBytes</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 检查当前缓冲区中的可读数据是否满足length长度</span></span><br><span class="line">    checkReadableBytes(length);</span><br><span class="line">    <span class="comment">// 将当前缓冲区的数据从readerIndex开始读取length个长度到目标dst缓冲区中. </span></span><br><span class="line">    <span class="comment">// 这个方法也就是拷贝一部分数据到新的缓冲区中,但是并不会改变当前缓冲区的readerIndex和writerIndex</span></span><br><span class="line">    getBytes(readerIndex, dst, dstIndex, length);</span><br><span class="line">    readerIndex += length;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们看一下写数据的API实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    ensureWritable(length);</span><br><span class="line">    setBytes(writerIndex, src, srcIndex, length);</span><br><span class="line">    writerIndex += length;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的<code>setBytes();</code>是由子类具体实现, 我们着重看一下<code>ensureWritable()</code>方法实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ensureWritable</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果要写入数据的字节小于0的话, 则直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">"minWritableBytes: %d (expected: &gt;= 0)"</span>, minWritableBytes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// minWritableBytes &lt;= capacity() - writerIndex, 要写入的字节数小于可写的字节数则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &lt;= writableBytes()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &gt; maxCapacity - writerIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">"writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s"</span>,</span><br><span class="line">                writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normalize the current capacity to the power of 2.</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = calculateNewCapacity(writerIndex + minWritableBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ResourceLeakDetector"><a href="#ResourceLeakDetector" class="headerlink" title="ResourceLeakDetector"></a>ResourceLeakDetector</h3><p><code>ResourceLeakDetector</code>用于检测内存泄漏. 它被所有ByteBuf实例共享.</p>
<h3 id="SwappedByteBuf"><a href="#SwappedByteBuf" class="headerlink" title="SwappedByteBuf"></a>SwappedByteBuf</h3><h2 id="AbstractReferenceCountedByteBuf"><a href="#AbstractReferenceCountedByteBuf" class="headerlink" title="AbstractReferenceCountedByteBuf"></a>AbstractReferenceCountedByteBuf</h2><h2 id="UnPooledHeapByteBuf"><a href="#UnPooledHeapByteBuf" class="headerlink" title="UnPooledHeapByteBuf"></a>UnPooledHeapByteBuf</h2><p>不使用对象池的基于堆内存分配的字节缓冲区. 每次IO读写的时候都会创建一个新的UnPooledHeapByteBuf.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Netty/">Netty</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/20/netty/ByteBuf/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/20/netty/ByteBuf/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/5/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/7/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github Card</p>
<div class="github-card" data-github="ming15" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Groovy/" title="Groovy">Groovy<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Haskell/" title="Haskell">Haskell<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/JMH/" title="JMH">JMH<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/JVM/" title="JVM">JVM<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaSE/" title="JavaSE">JavaSE<sup>28</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java工具/" title="Java工具">Java工具<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/MongoDB/" title="MongoDB">MongoDB<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Netty/" title="Netty">Netty<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Php/" title="Php">Php<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Reids/" title="Reids">Reids<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/TCP-IP/" title="TCP IP">TCP IP<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ZooKeeper/" title="ZooKeeper">ZooKeeper<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/asm/" title="asm">asm<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/guice/" title="guice">guice<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/http客户端/" title="http客户端">http客户端<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/http服务器/" title="http服务器">http服务器<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/linux/" title="linux">linux<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/memcached/" title="memcached">memcached<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/mgits/" title="mgits">mgits<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/mycat/" title="mycat">mycat<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/python2/" title="python2">python2<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/并发编程/" title="并发编程">并发编程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/序列化工具/" title="序列化工具">序列化工具<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/操作系统/" title="操作系统">操作系统<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/数据库/" title="数据库">数据库<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/日志工具/" title="日志工具">日志工具<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/构建工具/" title="构建工具">构建工具<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="http://www1.vertx3.cn" target="_blank" title="vertx3">vertx3</a>
            
          </li>
        
    </ul>
</div>

  

<div class="doubanshow">
<p class="asidetitle">Douban Show</p>
<div>
<script type="text/javascript" src="http://www.douban.com/service/badge/xxxyy/?show=collection&amp;n=12&amp;columns=3&amp;hidelogo=yes&amp;hideself=yes&amp;cat=book|movie" ></script>
</div>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=3253370782&verifier=e9ca895b&dpc=1"></iframe>
</div>


  

<div class="lofter">
<p class="asidetitle">Lofter</p>

 <iframe width="100%" height="39" class="share_self"  frameborder="0" scrolling="no" src="http://ming15.lofter.com/"></iframe>
</div>




</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 博客,我选择重构 <br/>
			重构使事情变得更美,更加正确</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/3253370782" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/ming15" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		<a href="https://www.douban.com/people/xxxyy" target="_blank" class="icon-douban" title="豆瓣"></a>
		
		
		<a href="http://www.zhihu.com/people/ming15" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="ming15">ming15</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"wanggnim"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F9e8fca440159a2125668804e46682db4' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
